import yaml
import sys
import os

if len(sys.argv) > 1:
    filename = sys.argv[1]
else:
    filename = '../config/test_component.yaml'

print sys.argv, len(sys.argv)
if not os.path.exists(filename):
    print 'File ' + filename + ' does not exist.'
   
print 'Using ' + filename + ' ...' 

fid = file(filename,'rU')
config = yaml.load(fid)
fid.close()

# Search for the key with name "component".  If part of the filename is the word "component" then assume that the first item on the list read is the name of the component
component_name = 'unknown'
variables = []
component_properties = []

if config.has_key('author'):
    author = config.pop('author')
else:
    author = 'Carsten Lemmen, <carsten.lemmen@hzg.de>'

if config.has_key('copyright'):
    copyright = config.pop('copyright')
else:
    copyright = 'Copyright (C) 2014, Helmholtz-Zentrum Geesthacht'

if config.has_key('component'):
  component = config.pop('component')
else:
  component=config.values()[0]
  component_name=config.keys()[0]
 
if component.has_key('short_name'):
  component_name=component.pop('short_name')
  
if component.has_key('grid'):
  grid=component.pop('grid')
  
for key, value in component.items():
    if type(value) is dict:
        variables.append({key : value})
        component.pop(key)
    else:
        component_properties.append({key : value})

import_variables=[]
export_variables=[]
module_list=[]
for item in variables:
  if item.values()[0].has_key('intent'):
    if item.values()[0]['intent']=='import' or item.values()[0]['intent']=='in': 
      import_variables.append(item)
    elif item.values()[0]['intent']=='both' or item.values()[0]['intent']=='inout':
      import_variables.append(item)
      export_variables.append(item)
    else:
      export_variables.append(item)
  else:
      export_variables.append(item)      
  if item.values()[0].has_key('module'):
    if item.values()[0].has_key('internal_name'):
      module_list.append('  use ' + item.values()[0]['module'] + ', only : ' 
                         + item.values()[0]['internal_name'])
       
filename = '../components/' + component_name + '_component.F90'
fid = file(filename,'w')

fid.write('!> @brief Implementation of an ESMF component for ' + component_name)
fid.write('''
!>
!> Do not edit this file, it is automatically generated!
!>
!> This computer program is part of MOSSCO. 
''')
fid.write('!> @copyright ' + copyright + '\n')
fid.write('!> @author ' + author + '\n')
fid.write('''
!
! MOSSCO is free software: you can redistribute it and/or modify it under the
! terms of the GNU General Public License v3+.  MOSSCO is distributed in the
! hope that it will be useful, but WITHOUT ANY WARRANTY.  Consult the file
! LICENSE.GPL or www.gnu.org/licenses/gpl-3.0.txt for the full license terms.
!
''')

fid.write('module ' + component_name + '_component\n') 
fid.write('''
  use esmf
  use mossco_variable_types
''')

for line in module_list:
    fid.write(line + '\n')

fid.write('''
  implicit none
  
  private
  public :: SetServices
  
  contains

  !> Provide an ESMF compliant SetServices routine, which defines
  !! entry points for Init/Run/Finalize
  subroutine SetServices(gridcomp, rc)
  
    type(ESMF_GridComp)  :: gridcomp
    integer, intent(out) :: rc

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_INITIALIZE, Initialize, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_RUN, Run, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_FINALIZE, Finalize, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    rc=ESMF_SUCCESS
    
  end subroutine SetServices

  !> Initialize the component
  !!
  subroutine Initialize(gridComp, importState, exportState, parentClock, rc)
    implicit none

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(ESMF_MAXSTR):: name, message, timeString, string
    type(ESMF_Clock)      :: clock
    type(ESMF_Time)       :: currTime, time
    logical               :: clockIsPresent
    type(ESMF_TimeInterval) :: timeInterval
   
    type(ESMF_Grid)       :: grid2, grid3
    type(ESMF_Mesh)       :: mesh
    integer               :: nimport,nexport
    type(ESMF_DistGrid)   :: distgrid
    type(ESMF_ArraySpec)  :: arrayspec
    type(ESMF_Field)      :: field

    integer                     :: lbnd(3), ubnd(3),farray_shape(3)
    integer                     :: myrank,i,j,k
    real(ESMF_KIND_R8), dimension(:,:,:), pointer :: farrayPtr3  
    real(ESMF_KIND_R8), dimension(:,:,:), pointer :: farrayPtr2 
    real(ESMF_KIND_R8)    :: h_r8

    !! Check whether there is already a clock (it might have been set 
    !! with a prior ESMF_gridCompCreate() call.  If not, then create 
    !! a local clock as a clone of the parent clock, and associate it
    !! with this component.  Finally, set the name of the local clock
    call ESMF_GridCompGet(gridComp, name=name, clockIsPresent=clockIsPresent, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    if (clockIsPresent) then
      call ESMF_GridCompGet(gridComp, clock=clock, rc=rc)     
    else
      clock = ESMF_ClockCreate(parentClock, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
      call ESMF_GridCompSet(gridComp, clock=clock, rc=rc)    
    endif
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_ClockSet(clock, name=trim(name)//'_clock', rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    !! Log the call to this function
    call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_TimeGet(currTime,timeStringISOFrac=timestring)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    write(message,'(A)') trim(timestring)//' '//trim(name)//' initializing ...'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_TRACE)

    !! Log clock information 
    call ESMF_ClockGet(clock, startTime=time, rc=rc)
    call ESMF_TimeGet(time,timeStringISOFrac=string)
    write(message,'(A)') trim(timeString)//' '//trim(string)
    call ESMF_ClockGet(clock, timeStep=timeInterval, rc=rc)
    !call ESMF_TimeIntervalGet(timeInterval,timeStringISOFrac=string)
    !write(message,'(A)') trim(message)//'--'//trim(string)
    call ESMF_TimeIntervalGet(timeInterval,h_r8=h_r8)
    write(message,'(A,F6.2,A)') trim(message)//'--',h_r8,' h'
    call ESMF_ClockGet(clock, stopTime=time, rc=rc)
    call ESMF_TimeGet(time,timeStringISOFrac=string)
    write(message,'(A)') trim(message)//'--'//trim(string)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
         
    !> Here comes your own time initialization code
    !! In particular, this should contain
    !! 1. Setting your internal timestep and adding it to your clock, this could
    !!    be a timestep read from an external file
    !!    ESMF_TimeIntervalSet(timeStep)
    !!    ESMF_ClockSet(Clock, timeStep=timeStep)
    !!    The default behaviour is to take the parent's time step

    !> Create grids
    !> This example grid is a 1 x 1 x 1 grid, you need to adjust this 
    grid3 = ESMF_GridCreateNoPeriDim(minIndex=(/1,1,1/),maxIndex=(/1,1,1/), &
      coordSys=ESMF_COORDSYS_SPH_DEG,indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_AttributeSet(grid3,'creator',trim(name), rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    grid2 = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/),maxIndex=(/1,1/), &
      coordSys=ESMF_COORDSYS_SPH_DEG,indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_AttributeSet(grid3,'creator',trim(name), rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
''')

nimport = len(import_variables)
if nimport > 0:
    fid.write('    nimport = ' + str(nimport) + '\n')

for i in range(0,nimport):
    if variables[i].values()[0].has_key('standard_name'): 
        variable_name = variables[i].values()[0]['standard_name']
    else:
        variable_name = variables[i].keys()[0]
    fid.write('    !---- Import variable ' + str(i+1) + ': ' + variable_name + '\n')
    fid.write('''
    call ESMF_GridGet(grid3,distgrid=distgrid,rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_GridGetFieldBounds(grid=grid3,localDE=0,staggerloc=ESMF_STAGGERLOC_CENTER,&
      totalCount=farray_shape,rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_ArraySpecSet(arrayspec, rank=3, typekind=ESMF_TYPEKIND_R8, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)\n
    ''')      
    fid.write('    field = ESMF_FieldCreate(grid3, arrayspec, staggerloc=ESMF_STAGGERLOC_CENTER, &\n')
    fid.write('       name=\'' + variable_name + '\', rc=rc)')
    fid.write('''
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_AttributeSet(field,'creator',trim(name), rc=rc)    
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_StateAddReplace(importState,(/field/),rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    ''')
    
nexport = len(export_variables)
if nexport > 0:
    fid.write('    nexport = ' + str(nexport))
    for k in range(nexport):
        if variables[k].values()[0].has_key('standard_name'): 
            variable_name = variables[k].values()[0]['standard_name']
        else:
            variable_name = variables[k].keys()[0]
        fid.write('   !---- Export variable ' + str(k+1) + ': ' + variable_name + '\n')
        fid.write('    field = ESMF_FieldCreate(grid3, arrayspec, staggerloc=ESMF_STAGGERLOC_CENTER, &\n')
        fid.write('      name=\'' + variable_name + '\', rc=rc)')
        fid.write('''
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_AttributeSet(field,'creator',trim(name), rc=rc)    
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_StateAddReplace(exportState,(/field/),rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_FieldGet(field, localDe=0, farrayPtr=farrayPtr3, &
                       totalLBound=lbnd,totalUBound=ubnd, rc=rc) 
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

''')           
        if variables[k].values()[0].has_key('internal_name'): 
            if variables[k].values()[0].has_key('default_value'): 
                fid.write('    ' + variables[k].values()[0]['internal_name'] + ' =  ' 
                      + str(variables[k].values()[0]['default_value']) + '\n')
            fid.write('!    variables(:,:,:,' + str(k+1) + ') =  ' 
                     + variables[k].values()[0]['internal_name'] + '\n')
        elif variables[k].values()[0].has_key('default_value'): 
            fid.write('!    variables(:,:,:,' + str(k+1) + ') =  ' 
                      + str(variables[k].values()[0]['default_value']) + '\n')              
        fid.write('!    farrayPtr3=variables(:,:,:,' + str(k+1) + ')\n\n')        

    fid.write('''    
    !! Finally, log the successful completion of this function
    call ESMF_TimeGet(currTime,timeStringISOFrac=timestring)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    write(message,'(A)') trim(timestring)//' '//trim(name)//' initialized'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_TRACE)

  end subroutine Initialize

  subroutine Run(gridComp, importState, exportState, parentClock, rc)

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(ESMF_MAXSTR):: name, message, timeString
    type(ESMF_Clock)      :: clock
    type(ESMF_Time)       :: currTime, stopTime
    logical               :: clockIsPresent
    type(ESMF_TimeInterval) :: timeInterval

    integer(ESMF_KIND_I4) :: petCount, localPet, rank
    integer(ESMF_KIND_I8) :: advanceCount
    real(ESMF_KIND_R8)    :: h_r8

    real(ESMF_KIND_R8),pointer,dimension(:,:)  :: ptr_f2
    real(ESMF_KIND_R8),pointer,dimension(:,:,:):: ptr_f3
    type(ESMF_Field)        :: field

    call ESMF_GridCompGet(gridComp,petCount=petCount,localPet=localPet, &
      name=name, clockIsPresent=clockIsPresent, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    if (.not.clockIsPresent) then
      call ESMF_LogWrite('Required clock not found in '//trim(name), ESMF_LOGMSG_ERROR)
      call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    endif
    
    call ESMF_GridCompGet(gridComp, clock=clock, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_ClockGet(clock,currTime=currTime, advanceCount=advanceCount, &
      timeStep=timeInterval, stopTime=stopTime, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_TimeGet(currTime,timeStringISOFrac=timestring)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    write(message,'(A,I8)') trim(timestring)//' '//trim(name)//' running step ',advanceCount
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_TRACE)

    call ESMF_TimeGet(stopTime,timeStringISOFrac=timestring)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    write(message,'(20X,A,F6.2,A)') 'to '//trim(timeString)//' at ',h_r8,' h'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_TRACE)

    !> Here comes your code for reading the import states

#if 0
    do while (.not.ESMF_ClockIsStopTime(clock))

      call ESMF_ClockGet(clock,currTime=currTime, advanceCount=advanceCount, &
        rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
      call ESMF_TimeGet(currTime,timeStringISOFrac=timeString)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)      

      call ESMF_ClockGet(clock,startTime=currTime, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
      call ESMF_TimeGet(currTime,timeStringISOFrac=timeString)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)      

      call ESMF_ClockGet(clock,stopTime=currTime, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
      call ESMF_TimeGet(currTime,timeStringISOFrac=timeString)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)      


      write(0,*) advanceCount, timeString
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      !> @todo 
      ! Insert here your time step/run code
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      
      call ESMF_ClockAdvance(clock,rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    end do
#endif
    
    !! This component has no do loop over an internal timestep, it is advance with the
    !! timestep written into its local clock from a parent component
    call ESMF_TimeIntervalGet(timeInterval, h_r8=h_r8, rc=rc)
    write(0,*) advanceCount, timeString, h_r8
    
    call ESMF_ClockAdvance(clock, timeStep=timeInterval, rc=rc)
    
    call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_TimeGet(currTime,timeStringISOFrac=timestring, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    write(message,'(A,A)') trim(timeString)//' '//trim(name), &
          ' finished running.'
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_TRACE, rc=rc)
    
  end subroutine Run

  subroutine Finalize(gridComp, importState, exportState, parentClock, rc)
    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(ESMF_MAXSTR):: name, message, timeString
    type(ESMF_Clock)      :: clock
    type(ESMF_Time)       :: currTime
    logical               :: clockIsPresent

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !> @todo 
    ! Insert here your finalization code
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  end subroutine Finalize
''')


fid.write('end module ' + component_name + '_component') 
fid.close()

filename='../components/' + component_name + '_component.mk'
fid=open(filename,'w')
fid.write('''
# This Makefile is part of MOSSCO
#
# Do not edit this file, it is automatically generated by
''')
fid.write('# the call python @todo @todo')
fid.write('''
#
# @copyright Copyright (C) 2014, Helmholtz-Zentrum Geesthacht
# @author Carsten Lemmen, <carsten.lemmen@hzg.de>

#
# MOSSCO is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License v3+.  MOSSCO is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY.  Consult the file
# LICENSE.GPL or www.gnu.org/licenses/gpl-3.0.txt for the full license terms.
#
''')
fid.write('TARGETS += libmossco_' + component_name + '\n')
fid.write('LIBS_TO_CLEAN += libmossco_' + component_name + '.a\n\n')
fid.write('libmossco_' + component_name + ': libmossco_' + component_name + '_component\n')
fid.write('libmossco_' + component_name + '_component: prefix $(MOSSCO_LIBRARY_PATH)/libmossco_')
fid.write(component_name + '.a(' + component_name + '_component.o)\n')

fid.close()


