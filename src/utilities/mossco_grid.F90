!> @brief Implementation of grid utilities
!!
!! This computer program is part of MOSSCO.
!! @copyright Copyright 2014, 2015, 2016, 2017, 2018 Helmholtz-Zentrum Geesthacht
!! @author Carsten Lemmen <carsten.lemmen@hzg.de>
!! @author Hartmut Kapitza <hartmut.kapitza@hzg.de>
!
! MOSSCO is free software: you can redistribute it and/or modify it under the
! terms of the GNU General Public License v3+.  MOSSCO is distributed in the
! hope that it will be useful, but WITHOUT ANY WARRANTY.  Consult the file
! LICENSE.GPL or www.gnu.org/licenses/gpl-3.0.txt for the full license terms.
!
#define ESMF_CONTEXT  line=__LINE__,file=ESMF_FILENAME,method=ESMF_METHOD
#define ESMF_ERR_PASSTHRU msg="MOSSCO subroutine call returned error"
#define ESMF_FILENAME "mossco_grid.F90"

#define RANGE2D lbnd(1):ubnd(1),lbnd(2):ubnd(2)
#define RANGE2DDIM lbnd(1):ubnd(1)-1,lbnd(2):ubnd(2)-1
#define RANGE3D lbnd(1):ubnd(1),lbnd(2):ubnd(2),lbnd(3):ubnd(3)
#define RANGE3DDIM lbnd(1):ubnd(1)-1,lbnd(2):ubnd(2)-1,lbnd(3):ubnd(3)

#define _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(X) if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=X)) call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

module mossco_grid

  use esmf
  use mossco_strings

  implicit none

  public MOSSCO_GridCopyCoords
  public MOSSCO_GridCreateFromOtherGrid
  !public MOSSCO_GridAddCorners
  public MOSSCO_GridGetDepth
  public MOSSCO_GridIsConformable
  public MOSSCO_GridString

  private

contains

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridCreateRegional3D"
function MOSSCO_GridCreateRegional3D(name, rc) result(grid)

  character(len=*), intent(in) :: name
  integer,  intent(out), optional    :: rc
  type(ESMF_Grid)                    :: grid

  integer(ESMF_KIND_I4)      :: minIndex(3), maxIndex(3), regDecomp(3)
  type(ESMF_Index_Flag)      :: indexFlag
  type(ESMF_CoordSys_Flag)   :: coordSys
  integer(ESMF_KIND_I4)      :: localrc, i, lbnd(3), ubnd(3), rc_
  real(ESMF_KIND_R8),dimension(:),pointer :: coordX, coordY

  rc_ = ESMF_SUCCESS

  minIndex=(/1,1,1/)
  maxIndex=(/40,50,10/)
  regDecomp=(/4,3,3/)
  coordSys=ESMF_COORDSYS_SPH_DEG
  indexFlag=ESMF_INDEX_GLOBAL

  grid = ESMF_GridCreateNoPeriDim(minIndex=minIndex, maxIndex=maxIndex, &
    regDecomp=regDecomp, coordSys=coordSys, indexFlag=indexFlag,  &
    name=trim(name)//' grid', coordTypeKind=ESMF_TYPEKIND_R8, coordDep1=(/1/), &
    coorddep2=(/2/), rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

  call ESMF_GridAddCoord(grid,staggerloc=ESMF_STAGGERLOC_CENTER,rc=rc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

  !> This example grid is a 40 x 50 grid at 0.1 degree resolution from 0..4 deg East
  !> to 50 .. 55 deg North
  call ESMF_GridGetCoord(grid,coordDim=1,localDE=0,staggerloc=ESMF_STAGGERLOC_CENTER, &
    computationalLBound=lbnd, computationalUBound=ubnd, farrayPtr=coordX, rc=rc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

  do i=lbnd(1),ubnd(1)
    coordX(i) = 0 + 0.1 * i + 0.05
  enddo
  call ESMF_GridGetCoord(grid,coordDim=2,localDE=0,staggerloc=ESMF_STAGGERLOC_CENTER, &
    computationalLBound=lbnd, computationalUBound=ubnd, farrayPtr=coordY, rc=rc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  do i=lbnd(1),ubnd(1)
    coordY(i) = 50 + 0.1 * i + 0.05
  enddo

  if (present(rc)) rc = rc_

end function MOSSCO_GridCreateRegional3D

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridCreateRegional2D"
function MOSSCO_GridCreateRegional2D(name, rc) result(grid)

  character(len=*), intent(in) :: name
  integer,  intent(out), optional    :: rc
  type(ESMF_Grid)                    :: grid

  integer(ESMF_KIND_I4)      :: minIndex(2), maxIndex(2), regDecomp(2)
  type(ESMF_Index_Flag)      :: indexFlag
  type(ESMF_CoordSys_Flag)   :: coordSys
  integer(ESMF_KIND_I4)      :: localrc, i, lbnd(2), ubnd(2), rc_
  real(ESMF_KIND_R8),dimension(:),pointer :: coordX, coordY

  rc_ = ESMF_SUCCESS

  minIndex=(/1,1/)
  maxIndex=(/40,50/)
  regDecomp=(/4,3/)
  coordSys=ESMF_COORDSYS_SPH_DEG
  indexFlag=ESMF_INDEX_GLOBAL

  grid = ESMF_GridCreateNoPeriDim(minIndex=minIndex, maxIndex=maxIndex, &
    regDecomp=regDecomp, coordSys=coordSys, indexFlag=indexFlag,  &
    name=trim(name)//' grid', coordTypeKind=ESMF_TYPEKIND_R8, coordDep1=(/1/), &
    coorddep2=(/2/), rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

  call ESMF_GridAddCoord(grid,staggerloc=ESMF_STAGGERLOC_CENTER,rc=rc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

  !> This example grid is a 40 x 50 grid at 0.1 degree resolution from 0..4 deg East
  !> to 50 .. 55 deg North
  call ESMF_GridGetCoord(grid,coordDim=1,localDE=0,staggerloc=ESMF_STAGGERLOC_CENTER, &
    computationalLBound=lbnd, computationalUBound=ubnd, farrayPtr=coordX, rc=rc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

  do i=lbnd(1),ubnd(1)
    coordX(i) = 0 + 0.1 * i + 0.05
  enddo
  call ESMF_GridGetCoord(grid,coordDim=2,localDE=0,staggerloc=ESMF_STAGGERLOC_CENTER, &
    computationalLBound=lbnd, computationalUBound=ubnd, farrayPtr=coordY, rc=rc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  do i=lbnd(1),ubnd(1)
    coordY(i) = 50 + 0.1 * i + 0.05
  enddo

  if (present(rc)) rc = rc_

end function MOSSCO_GridCreateRegional2D

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridCopyFromForeignField"
  subroutine MOSSCO_GridCopyFromForeignField(gridComp, state, gridfieldName, &
    kwe, nlayer, grida, gridb, rc)

    use mossco_strings

    implicit none

    type(ESMF_GridComp), intent(in)           :: gridComp
    type(ESMF_State), intent(in)              :: state
    character(len=*), intent(in)              :: gridFieldName
    logical, intent(in), optional             :: kwe
    integer(ESMF_KIND_I4), optional, intent(in) :: nlayer
    type(ESMF_Grid), intent(out), optional    :: grida
    type(ESMF_Grid), intent(out), optional    :: gridb
    integer(ESMF_KIND_I4), intent(out), optional :: rc

    type(ESMF_Grid)                           :: grida_, gridb_
    integer(ESMF_KIND_I4)                     :: rc_, localrc, nlayer_

    character(len=ESMF_MAXSTR)                :: message, name
    integer(ESMF_KIND_I4)                     :: ubnd3(3), lbnd3(3), ubnd2(2), lbnd2(2)
    type(ESMF_StateItem_Flag)                 :: itemType
    type(ESMF_FieldStatus_Flag)               :: status
    type(ESMF_Field)                          :: field
    integer(ESMF_KIND_I4)                     :: rank

    rc_=ESMF_SUCCESS

    call ESMF_GridCompGet(gridComp, name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    call ESMF_StateGet(state, trim(gridFieldName), itemType=itemType, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (itemType /= ESMF_STATEITEM_FIELD) then
      call MOSSCO_MessageAdd(message, trim(name)//' cannot use non-field '//trim(gridFieldName)//' as grid')
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
      call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=localrc)
    endif

    call ESMF_StateGet(state, trim(gridFieldName), field=field, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    call ESMF_FieldGet(field, status=status, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (status == ESMF_FIELDSTATUS_EMPTY) then
      call MOSSCO_MessageAdd(message, trim(name)//' cannot use empty field '//trim(gridFieldName)//' as grid')
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
      call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=localrc)
    endif

    ! At this point we're sure we have a field with at least GRIDSET status
    call MOSSCO_MessageAdd(message, trim(name)//' uses foreign grid '//trim(gridFieldName))
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    call ESMF_FieldGet(field, rank=rank, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (rank < 2 .or. rank > 3) then
      call MOSSCO_MessageAdd(message, trim(name)//' cannot use field '//trim(gridFieldName)//' with rank /= 2 or 3')
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
      call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=localrc)
    end if

    call MOSSCO_MessageAdd(message, trim(name)//' uses foreign')
    write(message,'(A,I1)') trim(message)//' ', rank
    call MOSSCO_MessageAdd(message, 'D grid '//trim(gridFieldName))
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    call ESMF_FieldGet(field, grid=grida_, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (present(nlayer)) then
      gridb_ =  MOSSCO_GridCreateFromOtherGrid(grida_, nlayer=nlayer, rc=localrc)
    else
      gridb_ =  MOSSCO_GridCreateFromOtherGrid(grida_, nlayer=nlayer, rc=localrc)
    endif
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (present(grida)) grida=grida_
    if (present(gridb)) gridb=gridb_
    if (present(rc)) rc=rc_

  end subroutine MOSSCO_GridCopyFromForeignField

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridCreateFromOtherGrid"
  function MOSSCO_GridCreateFromOtherGrid(grida, kwe, nlayer, rc) result(gridb)

    implicit none

    type(ESMF_Grid), intent(in)                  :: gridA
    logical, intent(in), optional                :: kwe
    integer(ESMF_KIND_I4), intent(in), optional  :: nlayer
    integer(ESMF_KIND_I4), intent(out), optional :: rc
    type(ESMF_Grid)                              :: gridB

    integer(ESMF_KIND_I4)                     :: rc_, localrc, rank, deCount, nlayer_, i
    type(ESMF_DistGrid)                       :: distGridA, distGridB
    type(ESMF_CoordSys_Flag)                  :: coordSys
    integer(ESMF_KIND_I4)                     :: coordDimCount2(2), coordDimMap2(2,2)
    integer(ESMF_KIND_I4)                     :: coordDimCount3(3), coordDimMap3(3,3)
    integer(ESMF_KIND_I4), allocatable        :: ubnd(:), lbnd(:)
    type(ESMF_DeLayout)                       :: deLayout
    integer(ESMF_KIND_I4)                     :: ubnd2(2), lbnd2(2), ubnd3(3), lbnd3(3)
    !integer(ESMF_KIND_I4)                     :: distGridToArrayMap(2)
    integer,dimension(:,:)  ,allocatable,target :: minIndexPDe,maxIndexPDe
    integer,dimension(:,:,:),allocatable,target :: deBlockList
    character(len=ESMF_MAXSTR)                :: message, nameA, nameB

    nameA='gridA'
    nameB='gridB'

    rc_ = ESMF_SUCCESS
    nlayer_ = 1

    if (present(kwe)) rc_ = ESMF_SUCCESS
    if (present(nlayer)) nlayer_ = nlayer

    !write(0,*) '"'//trim(nameA)//'", "'//trim(nameB)//'"'

    call ESMF_GridGet(grida, rank=rank, distGrid=distGridA, name=nameA, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    !> @todo something strange here with names, somehow nameA is set to 'gridB'
    !write(0,*) '"'//trim(nameA)//'", "'//trim(nameB)//'"'

    if ((rank) == 3 .and. present(nlayer)) then
      write(message,'(A)') '  not allowed to provide nlayer argument with 3D grid'
      if (present(rc)) rc = ESMF_RC_ARG_BAD
      return
    endif

    if (rank>0) then
      allocate(ubnd(rank))
      allocate(lbnd(rank))
    endif

    call ESMF_DistGridGet(distGridA, deLayout=deLayout, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    call ESMF_DeLayoutGet(deLayout, deCount=deCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (rank == 3) then

      call ESMF_GridGet(grida, coordSys=coordSys, coordDimCount=coordDimCount3, &
        coordDimMap=coordDimMap3, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
        call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

      allocate(minIndexPDe(3,deCount))
      allocate(maxIndexPDe(3,deCount))
      allocate(deBlockList(3,2,deCount))

      call ESMF_DistGridGet(distGridA, minIndexPDe=minIndexPDe, &
                            maxIndexPDe=maxIndexPDe, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
        call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

      deBlockList(:,1,:) = minIndexPDe
      deBlockList(:,2,:) = maxIndexPDe

      distGridB = ESMF_DistGridCreate(minval(deBlockList(1:2,1,:),2), maxval(deBlockList(1:2,2,:),2), &
        int(deBlockList(1:2,:,:)), delayout=delayout, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
        call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

      nameB = trim(nameA)
      do i = 1, len_trim(nameB)-1
        if (nameB(i:i+1) == '3D') then
          nameB(i:i+1) = '2D'
          exit
        endif
        if (nameB(i:i+1) == '3d') then
          nameB(i:i+1) = '2d'
          exit
        endif
      enddo

      if (trim(nameB) == trim(nameA)) nameB = trim(nameA)//'_2d'

      gridb = ESMF_GridCreate(distGridB, name=trim(nameB), gridAlign=(/1,1/), &
        coordSys=coordSys, coordDimCount=int(coordDimCount3(1:2)),      &
        coordDimMap=int(coordDimMap3(1:2,1:2)), rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
        call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    else

      call ESMF_GridGet(grida, coordSys=coordSys, coordDimCount=coordDimCount2, &
        coordDimMap=coordDimMap2, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
        call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

      allocate(minIndexPDe(2,deCount))
      allocate(maxIndexPDe(2,deCount))
      allocate(deBlockList(3,2,deCount))

      call ESMF_DistGridGet(distGridA, minIndexPDe=minIndexPDe, &
                            maxIndexPDe=maxIndexPDe, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
        call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

      deBlockList(1:rank,1,:) = minIndexPDe
      deBlockList(1:rank,2,:) = maxIndexPDe

      deBlockList(rank+1,1,:) = 1
      deBlockList(rank+1,2,:) = nlayer_

      ! From getm
      !coordDimCount = (/ 1 , 1 , 3 /)     ! rectilinear horizontal coordinates
      !coordDimMap = reshape( (/1,2,1,0,0,2,0,0,3/) , (/3,3/) )
      !
      !coordDimCount = (/ 2 , 2 , 3 /)
      !coordDimMap = reshape( (/1,1,1,2,2,2,0,0,3/) , (/3,3/) ) ! (default)
      coordDimCount3 = (/coordDimCount2(1), coordDimCount2(2), 3/)
      coordDimMap3(1:2,1:2) = coordDimMap2(:,:)
      coordDimMap3(3,:) = (/1,2,3/)
      coordDimMap3(:,3) = 3

      distGridB = ESMF_DistGridCreate(minval(deBlockList(:,1,:),2), &
        maxval(deBlockList(:,2,:),2), deBlockList, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
        call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

      gridb = ESMF_GridCreate(distGridB, name=trim(nameB), gridAlign=(/1,1,1/), &
        coordSys=coordSys, coordDimCount=coordDimCount3, &
        coordDimMap=int(coordDimMap3(:,:)), rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
        call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    endif

    call ESMF_GridAddCoord(gridb, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    !> @todo: implement multidimensional grid coordinates in MOSSCO_GridCopyCoords
    call MOSSCO_GridCopyCoords(grida, gridb, coordDims=(/1,2/), rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (present(rc)) rc = rc_

  end function MOSSCO_GridCreateFromOtherGrid

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridCreateWithVertical3"
  function MOSSCO_GridCreateWithVertical3(grida, kwe, farrayPtr3, rc) result(gridb)

    implicit none

    type(ESMF_Grid), intent(in)                  :: gridA
    logical, intent(in), optional                :: kwe
    real(ESMF_KIND_R8), pointer                  :: farrayPtr3(:,:,:)
    integer(ESMF_KIND_I4), intent(out), optional :: rc
    type(ESMF_Grid)                              :: gridB

    integer(ESMF_KIND_I4)                     :: rc_, localrc, rank, deCount, nlayer_, i
    type(ESMF_DistGrid)                       :: distGridA, distGridB
    type(ESMF_CoordSys_Flag)                  :: coordSys
    integer(ESMF_KIND_I4)                     :: coordDimCount2(2), coordDimMap2(2,2)
    integer(ESMF_KIND_I4)                     :: coordDimCount3(3), coordDimMap3(3,3)
    integer(ESMF_KIND_I4), allocatable        :: ubnd(:), lbnd(:)
    type(ESMF_DeLayout)                       :: deLayout
    integer(ESMF_KIND_I4)                     :: ubndb(3), lbndb(3)
    !integer(ESMF_KIND_I4)                     :: distGridToArrayMap(2)
    integer,dimension(:,:)  ,allocatable,target :: minIndexPDe,maxIndexPDe
    integer,dimension(:,:,:),allocatable,target :: deBlockList
    character(len=ESMF_MAXSTR)                :: message, nameA, nameB
    real(ESMF_KIND_R8), pointer               :: coordB3(:,:,:) => null()


    nameA='gridA'
    nameB='gridB'

    rc_ = ESMF_SUCCESS
    if (present(kwe)) rc_ = ESMF_SUCCESS

    call ESMF_GridGet(grida, rank=rank, distGrid=distGridA, name=nameA, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if ((rank) /= 2) then
      write(message,'(A)') '  only rank 2 is allowed'
      if (present(rc)) rc = ESMF_RC_ARG_BAD
      return
    endif

    allocate(ubnd(rank))
    allocate(lbnd(rank))

    call ESMF_DistGridGet(distGridA, deLayout=deLayout, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call ESMF_DeLayoutGet(deLayout, deCount=deCount, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call ESMF_GridGet(grida, coordSys=coordSys, coordDimCount=coordDimCount2, &
      coordDimMap=coordDimMap2, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    coordDimCount3 = (/coordDimCount2(1), coordDimCount2(2), 3/)
    coordDimMap3(1:2,1:2) = coordDimMap2(:,:)
    coordDimMap3(3,:) = (/1,2,3/)
    coordDimMap3(:,3) = 3

    if (.not.associated(farrayPtr3)) then
      localrc = ESMF_RC_ARG_BAD
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    endif

    allocate(minIndexPDe(2,deCount))
    allocate(maxIndexPDe(2,deCount))
    allocate(deBlockList(3,2,deCount))

    call ESMF_DistGridGet(distGridA, minIndexPDe=minIndexPDe, &
      maxIndexPDe=maxIndexPDe, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    deBlockList(1:rank,1,:) = minIndexPDe
    deBlockList(1:rank,2,:) = maxIndexPDe
    deBlockList(rank+1,1,:) = 1
    deBlockList(rank+1,2,:) = size(farrayPtr3, dim=3)


    distGridB = ESMF_DistGridCreate(minval(deBlockList(:,1,:),2), &
      maxval(deBlockList(:,2,:),2), deBlockList, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    gridb = ESMF_GridCreate(distGridB, name=trim(nameB), gridAlign=(/1,1,1/), &
      coordSys=coordSys, coordDimCount=coordDimCount3, &
      coordDimMap=int(coordDimMap3(:,:)), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call ESMF_GridAddCoord(gridb, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_GridCopyCoords(grida, gridb, coordDims=(/1,2/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call ESMF_GridGetCoordBounds(gridb,coordDim=3,localDE=0, &
      exclusiveLBound=lbndB, exclusiveUBound=ubndB, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call ESMF_GridGetCoord(gridb, coordDim=3, localDE=0, &
      staggerloc=ESMF_STAGGERLOC_CENTER, farrayPtr=coordB3, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    coordB3(lbndB(1):ubndB(1),lbndB(2):ubndB(2),lbndB(3):ubndB(3)) &
      = farrayPtr3(:,:,:)

    if (present(rc)) rc = rc_

  end function MOSSCO_GridCreateWithVertical3

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridCopyCoords"
  subroutine MOSSCO_GridCopyCoords(grida, gridb, coordDims, rc)

    implicit none

    type(ESMF_Grid), intent(in)                  :: grida
    type(ESMF_Grid), intent(inout)               :: gridb
    integer(ESMF_KIND_I4), dimension(:)          :: coordDims
    integer(ESMF_KIND_I4), intent(out), optional :: rc

    integer(ESMF_KIND_I4)                     :: rc_, localrc, localDeCount
    integer(ESMF_KIND_I4)                     :: ubndA(3), lbndA(3), ubndB(3), lbndB(3)
    integer(ESMF_KIND_I4)                     :: coordDim, i, ranka, rankb, dimCountA, dimCountB
    real(ESMF_KIND_R8), pointer               :: coordA1(:), coordB1(:)
    real(ESMF_KIND_R8), pointer               :: coordA2(:,:), coordB2(:,:)
    real(ESMF_KIND_R8), pointer               :: coordA3(:,:,:), coordB3(:,:,:)
    character(len=ESMF_MAXSTR)                :: message

    integer(ESMF_KIND_I4), allocatable        :: coordDimCountA(:), coordDimCountB(:)

    rc_ = ESMF_SUCCESS
    call ESMF_GridGet(grida, rank=ranka, dimCount=dimCountA, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    call ESMF_GridGet(gridb, rank=rankb, dimCount=dimCountB, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (ranka<2 .or.ranka>3) then
      write(message,'(A,I1)') '  input grid rank must be of rank 2 or 3, but is rank ',ranka
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
      if (present(rc)) rc = ESMF_RC_ARG_BAD
      return
    endif

    if (rankb<2 .or.rankb>3) then
      write(message,'(A,I1)') '  output grid rank must be of rank 2 or 3, but is rank ',rankb
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
      if (present(rc)) rc = ESMF_RC_ARG_BAD
      return
    endif

    call ESMF_GridGet(grida, localDeCount=localDeCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (localDeCount<1) return
    call ESMF_GridGet(gridb, localDeCount=localDeCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (localDeCount<1) return

    allocate(coordDimCountA(dimCountA))

    call ESMF_GridGet(grida, coordDimCount=coordDimCountA, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    allocate(coordDimCountB(dimCountB))
    call ESMF_GridGet(gridb, coordDimCount=coordDimCountB, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

    if (dimCountA < ubound(coordDims,1)) then
      write(message,'(A,I1,A)') '  input grid must have at least', ubound(coordDims,1), ' dimensions'
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
      if (present(rc)) rc = ESMF_RC_ARG_BAD
      return
    endif

    if (ubound(coordDims,1) > dimCountB) then
      write(message,'(A,I1,A)') '  output grid must have at least', ubound(coordDims,1), ' dimensions'
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
      if (present(rc)) rc = ESMF_RC_ARG_BAD
      return
    endif

    do i=1, ubound(coordDims,1)

      call ESMF_GridGetCoordBounds(gridb,coordDim=i,localDE=0, &
        exclusiveLBound=lbndB, exclusiveUBound=ubndB, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
        call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

      if (any(ubndB(1:coordDimCountB(i))-lbndB(1:coordDimCountB(i)) < 0)) then
        write(message,'(A)') '  no coord data on this DE, skipped'
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_WARNING)
        cycle
      endif

      call ESMF_GridGetCoordBounds(grida,coordDim=i,localDE=0, &
        exclusiveLBound=lbndA, exclusiveUBound=ubndA, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

      if (any(ubndA(1:coordDimCountA(i))-lbndA(1:coordDimCountA(i)) < 0)) then
        write(message,'(A)') '  no coord data on this DE, skipped'
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
        cycle
      endif

      select case (coordDimCountA(i))
      case (1)
        call ESMF_GridGetCoord(gridb, coordDim=i, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &
          farrayPtr=coordB1, rc=localrc)
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
          call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

        call ESMF_GridGetCoord(grida,coordDim=i,localDE=0,staggerloc=ESMF_STAGGERLOC_CENTER, &
           farrayPtr=coordA1,rc=localrc)
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
          call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

        coordB1(lbndB(1):ubndB(1)) = coordA1(lbndB(1):ubndB(1))
      case (2)
        call ESMF_GridGetCoord(gridb, coordDim=i, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &
          farrayPtr=coordB2, rc=localrc)
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
          call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

        call ESMF_GridGetCoord(grida,coordDim=i,localDE=0,staggerloc=ESMF_STAGGERLOC_CENTER, &
           farrayPtr=coordA2,rc=localrc)
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
          call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

        coordB2(lbndB(1):ubndB(1),lbndB(2):ubndB(2)) = coordA2(lbndA(1):ubndA(1),lbndA(2):ubndA(2))
      case (3)
        call ESMF_GridGetCoord(gridb, coordDim=i, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &
          farrayPtr=coordB3, rc=localrc)
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
          call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

        call ESMF_GridGetCoord(grida,coordDim=i,localDE=0,staggerloc=ESMF_STAGGERLOC_CENTER, &
           farrayPtr=coordA3,rc=localrc)
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc_)) &
          call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

        coordB3(lbndB(1):ubndB(1),lbndB(2):ubndB(2),lbndB(3):ubndB(3)) &
          = coordA3(lbndA(1):ubndA(1),lbndA(2):ubndA(2),lbndA(3):ubndA(3))
      case default
      end select
    enddo

    if (allocated(coordDimCountA)) deallocate(coordDimCountA)
    if (allocated(coordDimCountB)) deallocate(coordDimCountB)

    if (present(rc)) rc=rc_

  end subroutine MOSSCO_GridCopyCoords

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridString"
subroutine MOSSCO_GridString(grid, message, kwe, length, options, staggerLoc, rc)

  type(ESMF_Grid), intent(in)                    :: grid
  character(len=ESMF_MAXSTR), intent(inout)      :: message
  logical, intent(in), optional                  :: kwe
  integer(ESMF_KIND_I4), intent(inout), optional :: length
  character(len=ESMF_MAXSTR), intent(in), allocatable, optional :: options(:)
  integer(ESMF_KIND_I4), intent(out), optional   :: rc
  type(ESMF_StaggerLoc), intent(in), optional    :: staggerLoc

  integer(ESMF_KIND_I4)   :: rc_, length_, rank, localrc, i
  character(ESMF_MAXSTR)  :: string, name, formatString

  logical                            :: isPresent
  integer(ESMF_KIND_I4), allocatable :: ubnd(:), lbnd(:)
  character(len=ESMF_MAXSTR), allocatable  :: options_(:)
  type(ESMF_StaggerLoc)              :: staggerLoc_
  integer(ESMF_KIND_I4), pointer     :: mask1(:) => null()
  integer(ESMF_KIND_I4), pointer     :: mask2(:,:) => null()
  integer(ESMF_KIND_I4), pointer     :: mask3(:,:,:) => null()

  rc_ = ESMF_SUCCESS
  staggerLoc_ = ESMF_STAGGERLOC_CENTER

  if (present(kwe)) rc_ = ESMF_SUCCESS
  if (present(options)) then
    if (allocated(options)) then
      allocate(options_(size(options)), stat=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
      do i=lbound(options,1),ubound(options,1)
        call MOSSCO_StringCopy(options_(i),options(i))
      enddo
    endif
  else
    allocate(options_(1))
    options_(1)='creator'
  endif
  if (present(staggerLoc)) staggerLoc_ = staggerLoc

  call ESMF_GridGet(grid, name=name, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_AttributeGet(grid, name='creator', isPresent=isPresent, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if (isPresent) then
    call ESMF_AttributeGet(grid, name='creator', value=string, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    call MOSSCO_MessageAdd(message, ' ['//string)
    call MOSSCO_MessageAdd(message, ']'//name)
  else
    call MOSSCO_MessageAdd(message,name)
  endif

  call ESMF_GridGet(grid, rank=rank, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  write(formatString,'(A)') '(A,'//intformat(rank)//')'
  write(string, formatString) '(r=',rank

  call MOSSCO_MessageAdd(message, string)

  allocate(ubnd(rank), stat=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
  allocate(lbnd(rank), stat=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_GridGetFieldBounds(grid, totalUBound=ubnd, &
        totalLBound=lbnd, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  write(formatString,'(A)') '(X,'//intformat(ubnd(1)-lbnd(1)+1)//')'
  write(string,formatString) ubnd(1)-lbnd(1)+1
  do i=2, rank
    write(formatString,'(A)') '(A,'//intformat(ubnd(i)-lbnd(i)+1)//')'
    write(string,formatString) trim(string)//'x',ubnd(i)-lbnd(i)+1
  enddo

  call ESMF_GridGetItem(grid, ESMF_GRIDITEM_MASK, &
    staggerLoc=staggerLoc, isPresent=isPresent, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  !> @todo add GRIDITEM_AREA
  if (isPresent) then
    if (rank==1) then
      call ESMF_GridGetItem(grid, ESMF_GRIDITEM_MASK, farrayPtr=mask1, &
        staggerLoc=staggerLoc, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

      write(formatString,'(A)') '(A,'//intformat(count(mask1>0))//')'
      write(string,formatString) trim(string)//' m=',count(mask1>0)

    elseif (rank==2) then
      call ESMF_GridGetItem(grid, ESMF_GRIDITEM_MASK, farrayPtr=mask2, &
        staggerLoc=staggerLoc, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

      write(formatString,'(A)') '(A,'//intformat(count(mask2>0))//')'
      write(string,formatString) trim(string)//' m=',count(mask2>0)

    elseif (rank==3) then
      call ESMF_GridGetItem(grid, ESMF_GRIDITEM_MASK, farrayPtr=mask3, &
        staggerLoc=staggerLoc, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

      write(formatString,'(A)') '(A,'//intformat(count(mask3>0))//')'
      write(string,formatString) trim(string)//' m=',count(mask3>0)

    endif
  endif

  call MOSSCO_MessageAdd(message, trim(string)//')', rc=localrc)

  nullify(mask1)
  nullify(mask2)
  nullify(mask3)
  deallocate(ubnd, stat=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
  deallocate(lbnd, stat=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  length_=len_trim(message)
  if (present(length)) length=length_
  if (present(rc)) rc=rc_

end subroutine MOSSCO_GridString

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridPrintBlockList"
subroutine MOSSCO_GridPrintBlockList(grid, rc)

  type(ESMF_Grid), intent(in)                    :: grid
  integer(ESMF_KIND_I4), intent(out), optional   :: rc

  integer(ESMF_KIND_I4)          :: localrc, rc_
  type(ESMF_DistGrid)            :: distGrid

  call ESMF_GridGet(grid, distGrid=distGrid, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call MOSSCO_DistGridPrintBlockList(distGrid, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if (present(rc)) rc = rc_

end subroutine MOSSCO_GridPrintBlockList

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_DistGridPrintBlockList"
subroutine MOSSCO_DistGridPrintBlockList(distGrid, rc)

  type(ESMF_DistGrid), intent(in)                    :: distGrid
  integer(ESMF_KIND_I4), intent(out), optional   :: rc

  integer(ESMF_KIND_I4)          :: localrc, rc_
  type(ESMF_DeLayout)            :: deLayout

  call ESMF_DistGridGet(distGrid, deLayout=deLayout, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call MOSSCO_DeLayoutPrintBlockList(deLayout, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if (present(rc)) rc = rc_

end subroutine MOSSCO_DistGridPrintBlockList

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_DeLayoutPrintBlockList"
subroutine MOSSCO_DeLayoutPrintBlockList(deLayout, rc)

  type(ESMF_DeLayout), intent(in)                    :: deLayout
  integer(ESMF_KIND_I4), intent(out), optional   :: rc

  integer(ESMF_KIND_I4)              :: localrc, deCount, rank, localDeCount, rc_
  integer(ESMF_KIND_I4), allocatable :: deBlockList(:,:,:)
  character(len=ESMF_MAXSTR)         :: message

  call ESMF_DeLayoutGet(deLayout, deCount=deCount, localDeCount=localDeCount, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if (localDeCount /= 1 ) then
    write(message, '(A,I3)') '  cannot handle localDeCount /= 1'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR)
    call ESMF_Finalize()
  endif

  if (allocated(deBlockList)) deallocate(deBlockList)
  if (deCount<=0) then
    write(message, '(A,I3)') '  cannot handle deCount less than 1 (',deCount,')'
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
  endif

  allocate(deBlockList(rank,2,deCount))
  !call MOSSCO_MatrixFilePrint(deBlocklist(:,1,:), filename, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  !call MOSSCO_MatrixFilePrint(deBlocklist(:,1,:), filename, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_DeLayoutPrint(deLayout, rc=localrc)

  if (allocated(deBlockList)) deallocate(deBlockList)
  if (present(rc)) rc = rc_

end subroutine MOSSCO_DeLayoutPrintBlockList

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_VmGetRectangleDecomposition"
subroutine MOSSCO_VmGetRectangleDecomposition(vm, decomposition, rc)

  type(ESMF_Vm), intent(in)           :: vm
  integer(ESMF_KIND_I4), intent(inout), allocatable :: decomposition(:)
  integer,  intent(out), optional     :: rc

  integer(ESMF_KIND_I4)          :: rc_, localrc, petCount, i, j
  character(len=ESMF_MAXSTR)     :: message

  rc_ = ESMF_SUCCESS
  if (allocated(decomposition)) then
    if (size(decomposition) /= 2) then
      write(message, '(A)') '  invalid decomposition supplied'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR)
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
    endif
  else
    allocate(decomposition(2), stat=localrc)
  endif

  call ESMF_VmGet(vm, petCount=petCount, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  i = int(sqrt(petCount*1.0)) + 1
  j = petCount / i + 1
  decomposition(1) = i
  decomposition(2) = j
  write(message, '(A,I3,A,I2, A,I2,A,I2, A,I2)') '  decomposition for ', petCount,': ', &
    decomposition(1), ' x ',decomposition(1), ' ', i, ' x ', j
  call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

  do while (i > 1)
    i = i - 1
    j = (petCount / i) + 1
    do while (i * (j - 1) >= petCount)
      j = j - 1
    enddo

    if (i * j < decomposition(1) * decomposition(2) ) then
      decomposition(1) = i
      decomposition(2) = j
      write(message, '(A,I3,A,I2, A,I2,A,I2, A,I2)') '  decomposition for ', petCount,': ', &
        decomposition(1), ' x ',decomposition(1), ' ', i, ' x ', j
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
    endif

    if (decomposition(1) * decomposition(2) == petCount) exit
  enddo

  write(message, '(A,I3,A,I2, A,I2,A,I2, A,I2)') '  decomposition for ', petCount,': ', &
    decomposition(1), ' x ',decomposition(1), ' ', i, ' x ', j
  call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

  if (present(rc)) rc = rc_

end subroutine MOSSCO_VmGetRectangleDecomposition

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridGetDepth"
subroutine MOSSCO_GridGetDepth(grid, kwe, depth, height, interface, rc)

  type(ESMF_Grid), intent(in)           :: grid
  logical, intent(in), optional         :: kwe
  real(ESMF_KIND_R8), intent(inout), optional, pointer    :: depth(:,:,:)
  real(ESMF_KIND_R8), intent(inout), optional, pointer    :: height(:,:,:)
  real(ESMF_KIND_R8), intent(out), optional, pointer      :: interface(:,:,:)
  integer(ESMF_KIND_I4),  intent(out), optional  :: rc

  integer(ESMF_KIND_I4), allocatable :: ifUbnd(:), iflbnd(:), ubnd(:), lbnd(:)
  integer(ESMF_KIND_I4)          :: rc_, localrc, i, j, k
  character(len=ESMF_MAXSTR)     :: message
  real(ESMF_KIND_R8), pointer    :: interface_(:,:,:)

  rc_ = ESMF_SUCCESS
  if (present(kwe)) rc_ = ESMF_SUCCESS
  if (present(rc))  rc = rc_

  allocate(ubnd(3), stat=localrc)
  allocate(lbnd(3), stat=localrc)
  allocate(ifubnd(3), stat=localrc)
  allocate(iflbnd(3), stat=localrc)

  call ESMF_GridGetCoordBounds(grid, coordDim=3, staggerloc=ESMF_STAGGERLOC_CENTER, &
    exclusiveLBound=lbnd, exclusiveUbound=ubnd, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_GridGetCoordBounds(grid, coordDim=3, staggerloc=ESMF_STAGGERLOC_CENTER_VFACE, &
    exclusiveLBound=iflbnd, exclusiveUbound=ifubnd, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if (ubnd(1) /= ifubnd(1) .or. lbnd(1) /= iflbnd(1) &
      .or. ubnd(2) /= ifubnd(2) .or. lbnd(2) /= iflbnd(2)) then
      write(0,*) '  ubnd = ', ubnd
      write(0,*) 'ifubnd = ', ifubnd
      write(0,*) '  lbnd = ', lbnd
      write(0,*) 'iflbnd = ', iflbnd
      if (ESMF_LogFoundError(ESMF_RC_VAL_ERRBOUND, ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) &
          call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  endif

  call ESMF_GridGetCoord(grid, coordDim=3, staggerloc=ESMF_STAGGERLOC_CENTER_VFACE, &
    farrayPtr=interface_, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  !call ESMF_GridValidate(grid, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  !call ESMF_GridPrint(grid) ! interface not implemented (but needed...)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    !write(0,*) lbound(interface_),ubound(interface_)
    !write(0,*) iflbnd, ifubnd
    !> @todo something is wrong with iflbnd and ifubnd
    !> we correct them here to the dimensions of interface_, but really
    !> this should come from the grid itself
  iflbnd=lbound(interface_)
  ifubnd=ubound(interface_)

  if (present(height)) then
    if (associated(height)) then

      !> Make sure that allocated height is the same dimensions
      !> as the grid_center stagger
      if (any(ubound(height) /= ubnd) .or. any(lbound(height) /= lbnd)) then
        if (ESMF_LogFoundError(ESMF_RC_VAL_ERRBOUND, ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) &
          call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
      endif
    else
      allocate(height(RANGE3D), stat=localrc)
    endif

    do k = 0, ubnd(3) - lbnd(3)
      !write(0,*) 'k=',k,'h=',lbound(height,3),ubound(height,3), 'if=',lbound(interface_,3),ubound(interface_,3)
      !write(0,*) 'h=',lbnd(3)+k, 'if=',iflbnd(3) + k, iflbnd(3) + k + 1
      height(RANGE2D,lbnd(3)+k) =  interface_(RANGE2D, iflbnd(3) + k + 1) &
        - interface_(RANGE2D, iflbnd(3) + k)
    enddo
  endif

  if (present(depth)) then

    if (associated(depth)) then

      !> Make sure that allocated depth is the same dimensions
      !> as the grid_center stagger
      if (any(ubound(depth) /= ubnd) .or. any(lbound(depth) /= lbnd)) then
        if (ESMF_LogFoundError(ESMF_RC_VAL_ERRBOUND, ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) &
          call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
      endif
    else
      allocate(depth(RANGE3D), stat=localrc)
    endif

    do k = 0, ubnd(3) - lbnd(3)
      depth(RANGE2D,lbnd(3)+k) =  0.5 * ( &
      interface_(RANGE2D, iflbnd(3) + k + 1) &
        + interface_(RANGE2D, iflbnd(3) + k))
    enddo
  endif

  if (allocated(ubnd)) deallocate(ubnd)
  if (allocated(lbnd)) deallocate(lbnd)
  if (allocated(ifubnd)) deallocate(ifubnd)
  if (allocated(iflbnd)) deallocate(iflbnd)

  if (present(interface)) interface => interface_

end subroutine MOSSCO_GridGetDepth

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridIsConformable"
subroutine MOSSCO_GridIsConformable(gridA, gridB, isConformable, rc)

  type(ESMF_Grid), intent(in)           :: gridA
  type(ESMF_Grid), intent(in)           :: gridB
  logical, intent(out)                  :: isConformable
  integer(ESMF_KIND_I4),  intent(out), optional  :: rc

  integer(ESMF_KIND_I4), allocatable, dimension(:)  :: ubndA, lbndA, ubndB, lbndB

  integer(ESMF_KIND_I4)          :: rc_, localrc, i, rankA, rankB
  character(len=ESMF_MAXSTR)     :: message

  type(ESMF_CoordSys_Flag)       :: coordSysA, coordSysB

  rc_ = ESMF_SUCCESS
  if (present(rc))  rc = rc_
  isConformable = .false.

  if (gridA == gridB) then
    isConformable = .true.
    return
  endif

  call ESMF_GridGet(gridA, rank=rankA, coordSys=coordSysA, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_GridGet(gridB, rank=rankB, coordSys=coordSysB, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  ! Grids with different rank are not conformable
  if (rankA /= rankB) return

  ! Grids with different may be conformable, but print a warning
  if ((coordSysA /= coordSysB)) then
    write(message, '(A)') '  compares grids with different coordinate systems'
    call MOSSCO_GridString(gridA, message)
    call MOSSCO_GridString(gridB, message)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
  endif

  allocate(lbndA(rankA), stat=localrc)
  allocate(lbndB(rankA), stat=localrc)
  allocate(ubndA(rankA), stat=localrc)
  allocate(ubndB(rankA), stat=localrc)

  call ESMF_GridGet(gridA, staggerloc=ESMF_STAGGERLOC_CENTER, &
    localDe=0, exclusiveLBound=lbndA, exclusiveUBound=ubndA, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_GridGet(gridB, staggerloc=ESMF_STAGGERLOC_CENTER, &
    localDe=0, exclusiveLBound=lbndB, exclusiveUBound=ubndB, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  !write(0,*) 'gridbounds: ',lbndA,':',ubndA,' .ne. ',lbndB,':',ubndB
  if (all(ubndA - lbndA == ubndB - lbndB)) isConformable = .true.

end subroutine MOSSCO_GridIsConformable

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridAddCorners"
subroutine MOSSCO_GridAddCorners(grid, kwe, rc)

  type(ESMF_Grid), intent(inout)                    :: grid
  type(ESMF_KeywordEnforcer), intent(in), optional  :: kwe
  integer(ESMF_KIND_I4),  intent(out), optional     :: rc

  integer(ESMF_KIND_I4), allocatable, dimension(:)  :: ubnd, lbnd

  integer(ESMF_KIND_I4)              :: rc_, localrc, i, rank, dimCount
  integer(ESMF_KIND_I4), allocatable :: coordDimCount(:)
  character(len=ESMF_MAXSTR)         :: message

  type(ESMF_CoordSys_Flag)       :: coordSys
  type(ESMF_TypeKind_Flag)       :: coordTypeKind
  type(ESMF_Index_Flag)          :: indexFlag
  type(ESMF_StaggerLoc)          :: staggerLoc
  type(ESMF_GridStatus_Flag)     :: status
  integer(ESMF_KIND_I4)          :: localDe = 0
  logical                        :: isPresent

  rc_ = ESMF_SUCCESS
  if (present(rc))  rc = rc_
  if (present(kwe)) rc_ = ESMF_SUCCESS

  call ESMF_GridGet(grid, coordTypeKind=coordTypeKind, dimCount=dimCount, &
    coordSys=coordSys, rank=rank, indexFlag=indexFlag, status=status, rc=localrc)

  !> Return if corner staggers are present or if center staggers are not present.
  if (rank==2) then
    call ESMF_GridGetCoord(grid, staggerLoc=ESMF_STAGGERLOC_CORNER, &
      isPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (isPresent) return

    staggerLoc = ESMF_STAGGERLOC_CENTER
    call ESMF_GridGetCoord(grid, staggerLoc=staggerLoc, &
      isPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (.not.isPresent) return
  endif

  if (rank == 3) then
    call ESMF_GridGetCoord(grid, staggerLoc=ESMF_STAGGERLOC_CORNER_VFACE, &
      isPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (isPresent) return

    call ESMF_GridGetCoord(grid, staggerLoc=ESMF_STAGGERLOC_CENTER_VFACE, &
      isPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (isPresent) return

    staggerloc=ESMF_STAGGERLOC_CENTER_VFACE
    call ESMF_GridGetCoord(grid, staggerLoc=staggerLoc, &
      isPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (.not.isPresent) then

      staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER
      call ESMF_GridGetCoord(grid, staggerLoc=staggerLoc, &
        isPresent=isPresent, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

      if (.not.isPresent) return
    endif
  endif

  if (staggerLoc == ESMF_STAGGERLOC_CENTER) then
    call ESMF_GridAddCoord(grid, staggerLoc=ESMF_STAGGERLOC_CORNER)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
  elseif (staggerLoc == ESMF_STAGGERLOC_CENTER_VFACE) then
    call ESMF_GridAddCoord(grid, staggerLoc=ESMF_STAGGERLOC_CORNER_VFACE)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
  elseif (staggerLoc == ESMF_STAGGERLOC_CENTER_VCENTER) then
    call ESMF_GridAddCoord(grid, staggerLoc=ESMF_STAGGERLOC_CORNER_VCENTER)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
  endif

  allocate(coordDimCount(dimCount))
  call ESMF_GridGet(grid, coordDimCount=coordDimCount, rc=localrc)

  do i = 1, dimCount

    allocate(ubnd(coordDimCount(i)))
    allocate(lbnd(coordDimCount(i)))

    ! if (coordDimCount(i) == 1) then
    !   call ESMF_GridGetCoord(grid, coordDim=i, localDe=localDe, &
    !     staggerLoc=staggerLoc, farrayPtr=farrayPtr1, rc=localrc)
    ! elseif (coordDimCount(i) == 2) then
    !   call ESMF_GridGetCoord(grid, coordDim=i, localDe=localDe, &
    !     staggerLoc=staggerLoc, farrayPtr=farrayPtr2, rc=localrc)
    ! elseif (coordDimCount(i) == 3) then
    !   call ESMF_GridGetCoord(grid, coordDim=i, localDe=localDe, &
    !     staggerLoc=staggerLoc, farrayPtr=farrayPtr3, rc=localrc)
    ! endif

    deallocate(ubnd)
    deallocate(lbnd)

  end do

  ! if (rank == 3) then
  !   write(message, '(A)') '-- rank 3 GriddAddCorners not yet implemented'
  !   call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING, ESMF_CONTEXT)
  !   return
  ! endif


end subroutine MOSSCO_GridAddCorners

#undef  ESMF_METHOD
#define ESMF_METHOD "MOSSCO_GridGetWidth"
subroutine MOSSCO_GridGetWidth(grid, kwe, xwidth, ywidth, rc)

  type(ESMF_Grid), intent(in)           :: grid
  logical, intent(in), optional         :: kwe
  real(ESMF_KIND_R8), intent(out), allocatable, dimension(:,:) :: xwidth, ywidth
  integer(ESMF_KIND_I4),  intent(out), optional  :: rc

  integer(ESMF_KIND_I4)          :: ubnd(2), lbnd(2), dimCount
  integer(ESMF_KIND_I4), allocatable, dimension(:)  :: coordDimCount
  integer(ESMF_KIND_I4)          :: rc_, localrc, i, rank
  character(len=ESMF_MAXSTR)     :: message
  real(ESMF_KIND_R8), pointer, dimension(:,:)       :: lon, lat, crnlon, crnlat
  real(ESMF_KIND_R8), allocatable, dimension(:,:) :: dlon, dlat, a
  type(ESMF_CoordSys_Flag)       :: coordSys
  real(ESMF_KIND_R8),parameter   :: radius = 6371000.0d0, pi=3.141592653589793d0

  rc_ = ESMF_SUCCESS
  if (present(kwe)) rc_ = ESMF_SUCCESS
  if (present(rc))  rc = rc_

  call ESMF_GridGet(grid, rank=rank, coordSys=coordSys, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if ( (coordSys /= ESMF_COORDSYS_SPH_DEG)) then
    rc_ = ESMF_RC_NOT_IMPL
    if (present(rc)) rc=rc_
    return
  endif

  call ESMF_GridGet(grid, dimCount=dimCount, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  allocate(coordDimCount(dimCount), stat=localrc)

  call ESMF_GridGet(grid, coordDimCount=coordDimCount, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  !write(0,*) 'dimCount', rank, dimCount, coordDimCount

  if ( (coordDimCount(1) /= 2 .or. coordDimCount(2) /= 2)) then
    call ESMF_LogWrite('  currently only handles 2D lat/lon coordinates', ESMF_LOGMSG_ERROR)
    rc_ = ESMF_RC_NOT_IMPL
    if (present(rc)) rc=rc_
    return
  endif

  call ESMF_GridGetCoordBounds(grid, coordDim=1, staggerloc=ESMF_STAGGERLOC_CENTER, &
    exclusiveLBound=lbnd, exclusiveUbound=ubnd, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_GridGetCoord(grid, coordDim=1, staggerloc=ESMF_STAGGERLOC_CORNER, &
    farrayPtr=crnlon, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_GridGetCoord(grid, coordDim=2, staggerloc=ESMF_STAGGERLOC_CORNER, &
    farrayPtr=crnlat, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_GridGetCoord(grid, coordDim=1, staggerloc=ESMF_STAGGERLOC_CENTER, &
    farrayPtr=lon, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_GridGetCoord(grid, coordDim=2, staggerloc=ESMF_STAGGERLOC_CENTER, &
    farrayPtr=lat, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  allocate(dlat(RANGE2D), stat=localrc)
  allocate(dlon(RANGE2D), stat=localrc)
  allocate(xwidth(RANGE2D), stat=localrc)
  allocate(ywidth(RANGE2D), stat=localrc)

  ! Calculate xwdith (with dlat = 0)
  dlon = 2 * (crnlon(RANGE2D) - lon(RANGE2D))

  ! Haversine: a = sin(dlat/2)**2 + cos(lat1/2) * cos(lat2/2) * sin(dlon/2)**2
  !            c = 2 * arcsin(min(1,sqrt(a)))
  !            d = R * c
  xwidth = radius * 2 * asin(cos(lat(RANGE2D)/2 * pi/180.0) * sin(dlon(RANGE2D)/2 * pi/180.0))

  ! Calculade ywidth (height) with dlon=0
  dlat = 2 * (crnlat(RANGE2D) - lat(RANGE2D))
  ywidth = radius * dlat * pi/180.0

  !if (allocated(a)) deallocate(a)
  if (allocated(dlon)) deallocate(dlon)
  if (allocated(dlat)) deallocate(dlat)
  if (allocated(coordDimCount)) deallocate(coordDimCount)

  if (present(rc)) rc=rc_

end subroutine MOSSCO_GridGetWidth

end module mossco_grid
