!> @brief Implementation of an ESMF component for erosion and sedimentation
!
!  This computer program is part of MOSSCO.
!> @copyright Copyright (C) 2013, 2014, 2015, 2016, 2017, 2018 Helmholtz-Zentrum Geesthacht
!> @author M. Hassan Nasermoaddeli, Bundesanstalt fÃ¼r Wasserbau
!> @author Carsten Lemmen <carsten.lemmen@hzg.de>
!
! MOSSCO is free software: you can redistribute it and/or modify it under the
! terms of the GNU General Public License v3+.  MOSSCO is distributed in the
! hope that it will be useful, but WITHOUT ANY WARRANTY.  Consult the file
! LICENSE.GPL or www.gnu.org/licenses/gpl-3.0.txt for the full license terms.
!

#define ESMF_CONTEXT  line=__LINE__,file=ESMF_FILENAME,method=ESMF_METHOD
#define ESMF_ERR_PASSTHRU msg="MOSSCO subroutine call returned error"
#undef ESMF_FILENAME
#define ESMF_FILENAME "erosed_component.F90"

#define _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(X) if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=X)) call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

#define ELEMENTS nmlb:nmub
#define RANGE1D lbnd(1):ubnd(1)
#define RANGE2D RANGE1D,lbnd(2):ubnd(2)
#define RANGE3D RANGE2D,lbnd(3):ubnd(3)
#define RANGE4D RANGE3D,lbnd(4):ubnd(4)

module erosed_component

  use esmf
  use mossco_component
  use mossco_state
  use mossco_field
  use mossco_grid
  use mossco_variable_types
  use mossco_attribute

  use erosed_driver !, only : initerosed, erosed, getfrac_dummy
  use precision, only : fp
  use mossco_state
  use BioTypes , only :  BioturbationEffect
  implicit none

  public :: SetServices

  private

 ! These Parameters are defined in sedparam.inc seperately for delft-routine
 ! integer, parameter :: SEDTYP_NONCOHESIVE_TOTALLOAD = 0
 ! integer, parameter :: SEDTYP_NONCOHESIVE_SUSPENDED = 1
 ! integer, parameter :: SEDTYP_COHESIVE              = 2

  !! @todo hn: read CF documnetation for correct name of this
  !size_classes_of_upward_flux_of_pim_at_bottom

  type :: ptrarray2D
     real(ESMF_KIND_R8),dimension(:,:),pointer           :: ptr=>NULL()
  end type ptrarray2D

  type(ptrarray2D),dimension(:),allocatable              :: size_classes_of_upward_flux_of_pim_at_bottom
  type(ptrarray2D)                                       :: rms_orbital_velocity, bottom_shear_stress
  type(ptrarray2D)                                       :: bottom_shear_stress_noncohesive, equilibrium_spm

  type(MOSSCO_VariableFArray2d),dimension(:),allocatable :: importList

  type (BioturbationEffect)                              :: BioEffects

  real   (kind=ESMF_KIND_R8),dimension(:,:,:)  ,pointer  :: interface_height_above_soil_surface=>null(),sigma_midlayer=>null(),sediment_mass=>null()
  real   (kind=ESMF_KIND_R8),dimension(:,:,:)  ,pointer  :: relative_layer_thickness=>null(), layer_thickness=>null()
  real   (kind=ESMF_KIND_R8),dimension(:,:,:)  ,pointer  :: depth_avg_spm_concentration=>null()! Dimensions (x,y,fraction index)
  real   (kind=ESMF_KIND_R8),dimension(:,:)    ,pointer  :: sum_depth_avg_spm_concentration=>null()!Dimensions (x,y)
  real   (kind=ESMF_KIND_R8),dimension(:,:,:,:),pointer  :: spm_concentration=>null() ! Dimensions (x,y,depth layer, fraction index)

  integer(kind=ESMF_KIND_I4),dimension(:,:)    ,pointer  :: mask=>NULL()
  real   (kind=ESMF_KIND_R8),dimension(:,:)    ,pointer  :: area=>NULL()
  integer(ESMF_KIND_I8)     ,dimension(:),allocatable    :: external_idx_by_nfrac,nfrac_by_external_idx
  integer                                                :: ubnd(4),lbnd(4)

   integer                                      :: nmlb           ! first cell number
   integer                                      :: nmub           ! last cell number
   integer                                      :: inum, jnum     ! number of elements in y and x directions , inum * jnum== nmub - nmlb + 1
   integer                                      :: flufflyr       ! switch for fluff layer concept
   integer                                      :: iunderlyr      ! Underlayer mechanism
   integer                                      :: nfrac          ! number of sediment fractions
   real(fp)                                     :: init_thick     ! Initial thickness of the bed layer
   real(fp)                                     :: porosity       ! porosity of the bed layer (ideally mixed single bed layer)
   real(fp)    , dimension(:,:)    , pointer    :: mfluff=>null() ! composition of fluff layer: mass of mud fractions [kg/m2]
   real(fp)    , dimension(:,:)    , pointer    :: frac=>null()
    !
    ! Local variables
    !
    integer     , dimension(:)  , allocatable   :: sedtyp       ! sediment type [-]
    real(fp)                                    :: g            ! gravitational acceleration [m/s2]
    real(fp)                                    :: morfac       ! morphological scale factor [-]
    real(fp)                                    :: rhow         ! density of water [kg/m3]
    real(fp)    , dimension(:)  , allocatable   :: cdryb        ! dry bed density [kg/m3]
    real(fp)    , dimension(:)  , allocatable   :: chezy        ! Chezy coefficient for hydraulic roughness [m(1/2)/s]
    real(fp)    , dimension(:)  , allocatable   :: h0           ! water depth old time level [m]
    real(fp)    , dimension(:)  , allocatable   :: h1           ! water depth new time level [m]
    real(fp)    , dimension(:)  , allocatable   :: rhosol       ! specific sediment density [kg/m3]
    real(fp)    , dimension(:)  , allocatable   :: sedd50       ! 50% diameter sediment fraction [m]
    real(fp)    , dimension(:)  , allocatable   :: sedd90       ! 90% diameter sediment fraction [m]
    real(fp)    , dimension(:)  , allocatable   :: taub, taubn   ! bottom shear stress [N/m2]
    real(fp)    , dimension(:)  , allocatable   :: umod         ! depth averaged flow magnitude [m/s]
    real(fp)    , dimension(:)  , allocatable   :: u_bot        ! velocity at the (center of the) bottom cell in u-direction
    real(fp)    , dimension(:)  , allocatable   :: v_bot        ! velocity at the (center of the) bottom cell in v-direction

    real(fp)    , dimension(:,:), allocatable   :: mass         ! sediment mass in bottom layer as an ideally mixed single bed layer, [kg/m2]
    real(fp)    , dimension(:,:), allocatable   :: massfluff    ! change in sediment composition of fluff layer [kg/m2]
    real(fp)    , dimension(:,:), allocatable   :: sink         ! sediment sink flux [m/s]
    real(fp)    , dimension(:,:), allocatable   :: sinkf        ! sediment sink flux fluff layer [m/s]
    real(fp)    , dimension(:,:), allocatable   :: sour         ! sediment source flux [kg/m2/s]
    real(fp)    , dimension(:,:), allocatable   :: sourf        ! sediment source flux fluff layer [kg/m2/s]
    real(fp)    , dimension(:,:), allocatable   :: ws           ! settling velocity [m/s]
    real(fp)    , dimension(:)  , allocatable   :: mudfrac
    logical                                     :: lexist, anymud, wave, bedmodel
    real(fp)    , dimension(:)  , allocatable   :: uorb, tper, teta ! Orbital velocity [m/s], Wave period, angle between current and wave
    real(fp)    , dimension(:)  , allocatable   :: eq_conc    ! equilibrium sand fraction concentration [g.m**-3]    integer :: unit707


 contains

#undef  ESMF_METHOD
#define ESMF_METHOD "SetServices"
  subroutine SetServices(gridcomp, rc)

    type(ESMF_GridComp)  :: gridcomp
    integer, intent(out) :: rc

    integer              :: localrc

    rc=ESMF_SUCCESS

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_INITIALIZE, phase=0, &
      userRoutine=InitializeP0, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_INITIALIZE, phase=1, &
      userRoutine=InitializeP1, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_INITIALIZE, phase=2, &
      userRoutine=InitializeP2, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_READRESTART, phase=1, &
      userRoutine=ReadRestart, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_RUN, Run, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_FINALIZE, Finalize, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine SetServices

#undef  ESMF_METHOD
#define ESMF_METHOD "InitializeP0"
  subroutine InitializeP0(gridComp, importState, exportState, parentClock, rc)

    implicit none

    type(ESMF_GridComp)         :: gridComp
    type(ESMF_State)            :: importState
    type(ESMF_State)            :: exportState
    type(ESMF_Clock)            :: parentClock
    integer, intent(out)        :: rc

    character(len=10)           :: InitializePhaseMap(2)
    character(len=ESMF_MAXSTR)  :: name
    type(ESMF_Time)             :: currTime
    integer                     :: localrc
    logical                     :: isPresent

    rc=ESMF_SUCCESS

    call MOSSCO_CompEntry(gridComp, parentClock, name=name, currTime=currTime, &
      importState=importState, exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    InitializePhaseMap(1) = "IPDv00p1=1"
    InitializePhaseMap(2) = "IPDv00p2=2"

    call ESMF_AttributeAdd(gridComp, convention="NUOPC", purpose="General", &
      attrList=(/"InitializePhaseMap"/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_AttributeSet(gridComp, name="InitializePhaseMap", valueList=InitializePhaseMap, &
      convention="NUOPC", purpose="General", rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompGet(gridComp, importStateIsPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (isPresent) call ESMF_StateValidate(importState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompGet(gridComp, exportStateIsPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (isPresent) call ESMF_StateValidate(exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call MOSSCO_CompExit(gridComp, localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine InitializeP0

#undef  ESMF_METHOD
#define ESMF_METHOD "InitializeP1"
  subroutine InitializeP1(gridComp, importState, exportState, parentClock, rc)

    implicit none

    type(ESMF_GridComp)    :: gridComp
    type(ESMF_State)       :: importState, exportState
    type(ESMF_Clock)       :: parentClock
    integer, intent(out)   :: rc

    integer                :: localrc, knum
    type(ESMF_Grid)        :: grid, foreign_grid, grid3
    type(ESMF_Field)       :: field
    type(ESMF_FieldBundle)        :: fieldBundle
    character(len=ESMF_MAXSTR)    :: foreignGridFieldName

    integer                   :: rank
    integer                   :: lun, istat,j
    logical                   :: opnd, isPresent

    character(ESMF_MAXSTR)    :: name, message
    type(ESMF_Clock)          :: clock
    type(ESMF_Time)           :: currTime

    logical                   :: foreignGridIsPresent=.false.

    integer(ESMF_KIND_I4), allocatable :: ubnd(:), lbnd(:)
! local variables
    real(fp),dimension(:), allocatable :: eropartmp, tcrdeptmp,tcrerotmp,depefftmp,depfactmp, &
                             &   parfluff0tmp,parfluff1tmp,tcrflufftmp, fractmp, wstmp, spm_const
    real (fp)                 :: pmcrittmp
    integer                   :: i
    type(ESMF_State)          :: paramState

    namelist /globaldata/g, rhow
    namelist /benthic/   nmlb       ! = 1  ! first cell number
    namelist /benthic/   nmub       ! = 1  ! last cell number
    namelist /benthic/   morfac     ! = 1.0! morphological scale factor [-]
    !
    ! -----------------------------------------------------------
    !
    namelist /benthic/   nfrac      ! = 2  ! number of sediment fractions
    namelist /benthic/   iunderlyr  ! = 2  ! Underlayer mechanism (default = 1)
    namelist /benthic/   flufflyr   ! = 1  ! switch for fluff layer concept
                                    !  0: no fluff layer (default)
                                    !  1: all mud to fluff layer, burial to bed layers
                                    !  2: part mud to fluff layer, other part to bed layers (no burial)
    namelist /benthic/   anymud     != .true.
    namelist /benthic/   bedmodel   ! = .true. means a simple bed model for tracking mass balanace at sea bed is activated

!#define DEBUG
    rc = ESMF_SUCCESS

    call MOSSCO_CompEntry(gridComp, parentClock, name=name, currTime=currTime, &
      importState=importState, exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompGet(gridComp, clock=clock, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

 !! get/set grid:
    !! rely on field with name foreignGridFieldName given as attribute and field
    !! in importState
    !! and just take the same grid&distgrid.

!!! Create Grid
    call ESMF_GridCompGet(gridComp, gridIsPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (isPresent) then
      call ESMF_GridCompGet(gridComp, grid=grid, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    else

    call ESMF_AttributeGet(importState, name='foreign_grid_field_name', &
      isPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (.not.isPresent) then
        inum=1
        jnum = 1
        knum = 30
        grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), &
                     maxIndex=(/inum,jnum/), &
                     regDecomp=(/1,1/), &
                     coordSys=ESMF_COORDSYS_SPH_DEG, &
                     name="erosed", &
                     coordTypeKind=ESMF_TYPEKIND_R8,coordDep1=(/1/), &
                     coorddep2=(/2/),rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_GridAddCoord(grid, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        write(message,'(A)') trim(name)//' uses a dummy 1x1x30 grid'
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)

    else

        call ESMF_AttributeGet(importState, name='foreign_grid_field_name', &
          value=foreignGridFieldName, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        foreignGridIsPresent=.true.

        call ESMF_StateGet(importState, trim(foreignGridFieldName), field, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        write(message, '(A)') trim(name)//' uses foreign grid from field'
        call MOSSCO_FieldString(field, message, rc=localrc)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

        call ESMF_FieldGet(field, grid=grid, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_GridGet(grid, rank=rank, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        allocate(ubnd(rank))
        allocate(lbnd(rank))

        if (rank==2) then

          call ESMF_GridGet(grid, ESMF_STAGGERLOC_CENTER, localDe=0,                   &
            exclusiveLBound=lbnd,exclusiveUBound=ubnd, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          inum=ubnd(1)-lbnd(1)+1
          jnum=ubnd(2)-lbnd(2)+1
          knum=30 ! default value
        endif

      if (rank==3) then

        write(message,'(A)') trim(name)//' uses foreign grid from field'
        call MOSSCO_FieldString(field, message, rc=localrc)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

        call ESMF_FieldGet(field, grid=grid3, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_FieldGetBounds(field, exclusiveLBound=lbnd,exclusiveUBound=ubnd, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        inum=ubnd(1)-lbnd(1)+1
        jnum=ubnd(2)-lbnd(2)+1
        knum=ubnd(3)-lbnd(3)+1

        grid = MOSSCO_GridCreateFromOtherGrid(grid3, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        endif

      endif

      call ESMF_GridCompSet(gridComp, grid=grid, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif

  !initialization

  bedmodel = .false.

  !> In globaldata.nml, global parameters for density of water (rhow)
  !> and gravitational acceleration (g) can be defined
  inquire ( file='globaldata.nml', exist=isPresent , opened=opnd, Number=lun )

  if (isPresent.and.(.not.opnd)) then

    call ESMF_UtilIOUnitGet(lun, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    open (unit=lun, file='globaldata.nml', action='read ', &
      status='old', delim='APOSTROPHE', iostat=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    read (lun, nml=globaldata, iostat = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    close (lun, iostat=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end if

  !> Add attributes from globaldata namelist to exportState

  call ESMF_AttributeSet(exportState, 'density_of_water', rhow, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_AttributeSet(exportState, 'acceleration_due_to_gravity', g, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  nmlb=1
  nmub = inum * jnum

  inquire ( file = 'benthic.nml', exist=isPresent , opened=opnd, Number = lun )

  if (isPresent.and.(.not.opnd)) then

    call ESMF_UtilIOUnitGet(lun, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    open (unit = lun, file = 'benthic.nml', action = 'read ', &
      status = 'old', delim = 'APOSTROPHE', iostat=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    read (lun, nml=benthic, iostat=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    close (lun)
  end if

  if (nmlb /= 1) then
    write(message,'(A)')  trim(name)//' benthic.nml::nmlb must be 1'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    localrc = ESMF_RC_ARG_BAD
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif

  if (nmub /= inum * jnum) then
    write(message,'(A)')  trim(name)//' benthic.nml::nmub overruled '//&
      'by number of elements in '
    call MOSSCO_GridString(grid, message)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
    nmub = inum * jnum
  endif

  call ESMF_AttributeSet(exportState, 'first_element_index', nmlb, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_AttributeSet(exportState, 'last_element_index', nmub, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_AttributeSet(exportState, 'morphological_time_factor', morfac, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_AttributeSet(exportState, 'mud_is_present', anymud, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (flufflyr == 0) then
    write(message,'(A)') '0: no fluff layer'
  elseif (flufflyr == 1) then
    write(message,'(A)') '1: all mud to fluff layer, burial to bed layer'
  elseif (flufflyr == 2) then
    write(message,'(A)') '2: parts of mud to fluff and bed layer, no burial'
  else
    localrc = ESMF_RC_ARG_BAD
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif
  call ESMF_AttributeSet(exportState, 'flufflayer_type', trim(message), rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (iunderlyr == 1) then
    write(message,'(A)') '1: no multibed layer'
  elseif (iunderlyr == 1) then
    write(message,'(A)') '2: multibed layer'
  else
    localrc = ESMF_RC_ARG_BAD
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif
  call ESMF_AttributeSet(exportState, 'underlayer mechanism', trim(message), rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_AttributeSet(exportState, 'number_of_spm_fractions', nfrac, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_AttributeSet(exportState, 'bedmodel_is_active', bedmodel, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call initerosed( nmlb, nmub, nfrac)

  if (.not.associated(BioEffects%ErodibilityEffect)) &
    allocate (BioEffects%ErodibilityEffect(inum, jnum))
  if (.not.associated(BioEffects%TauEffect)) &
    allocate (BioEffects%TauEffect(inum,jnum))
  if (.not.associated(depth_avg_spm_concentration)) &
    allocate(depth_avg_spm_concentration(inum,jnum,nfrac))

  if (.not.associated(sum_depth_avg_spm_concentration)) &
    allocate(sum_depth_avg_spm_concentration(inum,jnum))
  if (.not.associated(spm_concentration)) &
    allocate(spm_concentration(inum,jnum,knum,nfrac))

  allocate (cdryb     (nfrac))
  allocate (rhosol    (nfrac))
  allocate (sedd50    (nfrac))
  allocate (sedd90    (nfrac))
  allocate (sedtyp    (nfrac))

  allocate (chezy     (ELEMENTS))
  allocate (h0        (ELEMENTS))
  allocate (h1        (ELEMENTS))
  allocate (umod      (ELEMENTS))
  allocate (u_bot     (ELEMENTS))
  allocate (v_bot     (ELEMENTS))

  allocate (taub      (ELEMENTS))
  allocate (taubn     (ELEMENTS))
  allocate (eq_conc   (ELEMENTS))
  allocate (ws        (nfrac,ELEMENTS))
    !
  if (bedmodel) then
    allocate (mass (nfrac,ELEMENTS))
    mass = 0.0d0
  end if

!    allocate (massfluff (nfrac,ELEMENTS))
  allocate (sink      (nfrac,ELEMENTS))
  allocate (sinkf     (nfrac,ELEMENTS))
  allocate (sour      (nfrac,ELEMENTS))
  allocate (sourf     (nfrac,ELEMENTS))

  allocate (frac(nfrac,ELEMENTS))
  allocate (mfluff(nfrac,ELEMENTS))
  allocate (mudfrac (ELEMENTS))

  allocate (uorb      (ELEMENTS))
  allocate (tper      (ELEMENTS))
  allocate (teta      (ELEMENTS))

  !allocation of temporal variables
  allocate ( eropartmp (nfrac),tcrdeptmp(nfrac),tcrerotmp(nfrac),fractmp(nfrac), &
             & depefftmp(nfrac), depfactmp(nfrac),parfluff0tmp(nfrac), &
             & parfluff1tmp(nfrac), tcrflufftmp(nfrac),wstmp(nfrac),spm_const(nfrac), stat=localrc)

  if (localrc /= 0) then
      write(message, '(A)') trim(name)//' failed to allocate temporal variables'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  endif

  !Initialization
  sink = 0.0_fp
  sour = 0.0_fp
  sinkf=0.0_fp
  sourf=0.0_fp
!    massfluff=0.0_fp
  mudfrac = 0.0_fp
  mfluff =0.0_fp
  uorb = 0.0_fp
  tper = 1.0_fp
  teta = 0.0_fp
  wave = .false.

  BioEffects%TauEffect =1.0_fp
  BioEffects%ErodibilityEffect = 1.0_fp
!write (*,*)'in Init BioEffects%TauEffect ',BioEffects%TauEffect

  !sedtyp(1:nfrac) = 2 ! SEDTYP_NONCOHESIVE_SUSPENDED

  inquire (file='sedparams.txt', exist=isPresent, opened=opnd)

  if (isPresent.and.(.not.opnd)) then
      call ESMF_UtilIOUnitGet(lun, rc = localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      open (unit=lun, file = 'sedparams.txt', action = 'read ', status = 'old')

      write(message,'(A)')  trim(name)//' reads configuration from sedparams.txt'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

 ! non-cohesive sediment
      read (lun,*, iostat = istat) (sedtyp(i),i=1,nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) ( cdryb(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (rhosol(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (sedd50(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (sedd90(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (fractmp(i), i=1, nfrac)
      !if (istat ==0 ) read (lun,*, iostat = istat) ((frac(i,j), i=1, nfrac), j=nmlb,nmub)    ! fraction of each sedimt class from the whole
 ! cohesive sediment
      if (istat ==0 ) read (lun,*, iostat = istat) (eropartmp(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (tcrdeptmp(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (tcrerotmp(i), i=1, nfrac)
!      if (istat ==0 ) read (lun,*, iostat = istat) ((eropar(i,j), i=1, nfrac), j=nmlb,nmub)   ! erosion parameter for mud [kg/m2/s]
!      if (istat ==0 ) read (lun,*, iostat = istat) ((tcrdep(i,j), i=1, nfrac), j=nmlb,nmub)   ! critical bed shear stress for mud sedimentation [N/m2]
!      if (istat ==0 ) read (lun,*, iostat = istat) ((tcrero(i,j), i=1, nfrac), j=nmlb,nmub)   ! critical bed shear stress for mud erosion [N/m2]

 ! cohesive sediment
      if (istat ==0 ) read (lun,*, iostat = istat) pmcrittmp
      !if (istat ==0 ) read (lun,*, iostat = istat) (pmcrit (i), i = nmlb,nmub)
      if (istat ==0 ) read (lun,*, iostat = istat) betam                                      ! power factor for adaptation of critical bottom shear stress [-]
 ! sediment transport formulation
      if (istat ==0 ) read (lun,*, iostat = istat) alf1                                       ! calibration coefficient van Rijn (1984) [-]
      if (istat ==0 ) read (lun,*, iostat = istat) rksc
 ! fluff layer
      if (istat ==0 ) read (lun,*, iostat = istat) (depefftmp(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (depfactmp(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (parfluff0tmp(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (parfluff1tmp(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (tcrflufftmp(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (wstmp(i), i=1, nfrac)
      if (istat ==0 ) read (lun,*, iostat = istat) (spm_const(i), i=1, nfrac)
!      if (istat ==0 ) read (lun,*, iostat = istat) ((depeff(i,j), i=1, nfrac), j=nmlb,nmub)   ! deposition efficiency [-]
!      if (istat ==0 ) read (lun,*, iostat = istat) ((depfac(i,j), i=1, nfrac), j=nmlb,nmub)   ! deposition factor (flufflayer=2) [-]
!      if (istat ==0 ) read (lun,*, iostat = istat) ((parfluff0(i,j), i=1, nfrac), j=nmlb,nmub)! erosion parameter 1 [s/m]
!      if (istat ==0 ) read (lun,*, iostat = istat) ((parfluff1(i,j), i=1, nfrac), j=nmlb,nmub)! erosion parameter 2 [ms/kg]
!      if (istat ==0 ) read (lun,*, iostat = istat) ((tcrfluff(i,j), i=1, nfrac), j=nmlb,nmub) ! critical bed shear stress for fluff layer erosion [N/m2]
      if (istat ==0 ) read (lun,*, iostat = istat) wave
      if (istat ==0.and. bedmodel ) read (lun,*, iostat = istat) init_thick
      if (istat ==0.and. bedmodel ) read (lun,*, iostat = istat) porosity
      if (istat /= 0) then
        write(message,'(A)') trim(name)//' cannot read file sedparams.txt'
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
        write(message,'(A)') trim(name)//' hint: check nfrac is consistent in fabm.nml, benthic.nml and sedparams.txt'
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
        call MOSSCO_CompExit(gridComp, localrc)
        localrc = ESMF_RC_NOT_FOUND
        return
      endif

      close (lun)

      do i =nmlb, nmub
        eropar   (:,i) = eropartmp   (:)
        tcrdep   (:,i) = tcrdeptmp   (:)
        tcrero   (:,i) = tcrerotmp   (:)
        frac     (:,i) = fractmp     (:)
        pmcrit   (  i) = pmcrittmp
        depeff   (:,i) = depefftmp   (:)
        depfac   (:,i) = depfactmp   (:)
        parfluff0(:,i) = parfluff0tmp(:)
        parfluff1(:,i) = parfluff1tmp(:)
        tcrfluff (:,i) = tcrflufftmp (:)
        ws       (:,i) = wstmp       (:) ! initialization, for the case no sediment transport model is coupled with erosed
      end do

!      if (bedmodel) call init_mass(nfrac, frac,nmub, init_thick, porosity, rhosol,mass, area)

!      do i = 1, inum
!        do j = 1, jnum
!          spm_concentration (i,j,:) = spm_const (:)
!        end do
!      end do

    else
      write(message, '(A)') trim(name)//' cannot find optional file sedparams.txt'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
    end if

    !   Initial bed composition
    !
    ! composition of fluff layer: mass of mud fractions [kg/m2]
    if (iunderlyr==2 .and. flufflyr>0) mfluff  = 0.0_fp
    !
    !   Initial flow conditions
    !
    chezy   = 50.0_fp       ! Chezy coefficient for hydraulic roughness [m(1/2)/s]
    h1      = 0.03_fp        ! water depth [m]
    h0      = h1            ! @ToDo : read h0 from input data
    umod    = 0.0_fp        ! depth averaged flow magnitude [m/s]
    u_bot   = 0.0_fp        ! flow velocity in u-direction at (center of the ) bottm cell
    v_bot   = 0.0_fp        ! flow velocity in v-direction at (center of the ) bottm cell

    taub    = 0.0_fp
    taubn   = 0.0_fp
    eq_conc = 0.0_fp
#ifdef DEBUG
    ! Open file for producing output
!   call ESMF_UtilIOUnitGet(unit707, rc = localrc)
!   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
!   inquire (file ='delft_sediment.out', exist = lexist)

!! This file output is not MPI compatible
!   if (lexist) then

!       open (unit = unit707, file = 'delft_sediment.out', status = 'REPLACE', action = 'WRITE')
!   else
!       open (unit = unit707, file = 'delft_sediment.out', status = 'NEW', action = 'WRITE')
!   end if

!   write (unit707, '(A4,2x,A8,2x, A5,7x,A13,3x,A14,4x,A5,6x,A7, 10x, A4, 8x, A8)') &
!       'Step','Fractions','layer','Sink(g/m^2/s)','Source(g/m^2/s)', 'nfrac', 'mudfrac', 'taub', 'sink vel'
#endif

    allocate (size_classes_of_upward_flux_of_pim_at_bottom(nfrac))

!> not used fo export State, since sink,sour are used by bed module
!    allocate (size_classes_of_downward_flux_of_pim_at_bottom(1,1,nfrac))
!    size_classes_of_downward_flux_of_pim_at_bottom(1,1,:) = sour (:,1)

    allocate(external_idx_by_nfrac(nfrac))


    !! Prepare import state for fields needed in run
    if (wave) then
      allocate(importList(16))
    else
      allocate(importList(12))
    end if

    importList( 1)%name  = 'water_depth_at_soil_surface'
    importList( 1)%units = 'm'
    importList( 2)%name  = 'layer_height_at_soil_surface'
    importList( 2)%units = 'm'
    importList( 3)%name  = 'depth_averaged_x_velocity_in_water'
    importList( 3)%units = 'm.s-1'
    importList( 4)%name  = 'depth_averaged_y_velocity_in_water'
    importList( 4)%units = 'm.s-1'
    importList( 5)%name  = 'x_velocity_at_soil_surface'
    importList( 5)%units = 'm.s-1'
    importList( 6)%name  = 'y_velocity_at_soil_surface'
    importList( 6)%units = 'm.s-1'
    importList( 7)%name  = 'turbulent_diffusivity_of_momentum_at_soil_surface'
    importList( 7)%units = 'm2.s-1'
    importList( 8)%name  = 'maximum_bottom_stress'
    importList( 8)%units = 'Pa'
    importList( 9)%name  = 'Effect_of_MPB_on_critical_bed_shearstress_at_soil_surface'
    importList( 9)%units = '1'
    importList( 9)%optional = .true.
    importList(10)%name  = 'Effect_of_MPB_on_sediment_erodibility_at_soil_surface'
    importList(10)%units = '1'
    importList(10)%optional = .true.
    importList(11)%name  = 'Effect_of_Mbalthica_on_critical_bed_shearstress_at_soil_surface'
    importList(11)%units = '1'
    importList(11)%optional = .true.
    importList(12)%name  = 'Effect_of_Mbalthica_on_sediment_erodibility_at_soil_surface'
    importList(12)%units = '1'
    importList(12)%optional = .true.

    if (wave) then
       importList(13)%name  = 'wave_height'
       importList(13)%units = 'm'
       importList(14)%name  = 'wave_period'
       importList(14)%units = 's'
       importList(15)%name  = 'wave_number'
       importList(15)%units = 'm-1'
       importList(16)%name  = 'wave_direction'
       importList(16)%units = 'rad'
    end if

    do i = 1, ubound(importList,1)

      !> Skip foreign grid field as this has already been read
      if (foreignGridIsPresent) then
        if (trim(importList(i)%name) == foreignGridFieldName) cycle
      end if

      field = ESMF_FieldEmptyCreate(name=trim(importList(i)%name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_FieldEmptySet(field, grid, staggerloc=ESMF_STAGGERLOC_CENTER, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field, 'units', trim(importList(i)%units), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      write(message, '(A)') trim(name)//' created for import'
      call MOSSCO_FieldString(field, message, rc=localrc)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

      call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    end do

    fieldBundle = ESMF_FieldBundleCreate(name='concentration_of_SPM_in_water', &
      multiflag=.true., rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_FieldBundleSet(fieldBundle, grid, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_AttributeSet(fieldBundle,'creator', trim(name), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_StateAddReplace(importState, (/fieldBundle/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(message, '(A)') trim(name)// &
      ' created for import bundle concentration_of_SPM_in_water'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

    fieldBundle = ESMF_FieldBundleCreate(name='concentration_of_SPM_z_velocity_in_water', &
      multiflag=.true., rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_FieldBundleSet(fieldBundle, grid, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_AttributeSet(fieldBundle,'creator', trim(name), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_StateAddReplace(importState, (/fieldBundle/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(message, '(A)') trim(name)// &
      ' created for import bundle concentration_of_SPM_z_velocity_in_water'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

    fieldBundle = ESMF_FieldBundleCreate(&
      name='concentration_of_SPM_upward_flux_at_soil_surface', &
      multiflag=.true.,rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_FieldBundleSet(fieldBundle, grid, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_AttributeSet(fieldBundle, 'creator', trim(name), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_StateAddReplace(exportState, (/fieldBundle/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(message, '(A)') trim(name)// &
      ' created for export bundle concentration_of_SPM_upward_flux_at_soil_surface'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

    fieldBundle = ESMF_FieldBundleCreate(name='concentration_of_SPM_downward_flux_at_soil_surface', &
      multiflag=.true.,rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_FieldBundleSet(fieldBundle,grid,rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_AttributeSet(fieldBundle,'creator', trim(name), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_StateAddReplace(exportState, (/fieldBundle/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(message, '(A)') trim(name)// &
      ' created for export bundle concentration_of_SPM_downward_flux_at_soil_surface'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

    if (bedmodel) then

      field = ESMF_FieldCreate(grid, &
        typekind=ESMF_TYPEKIND_R8, &
        name='sediment_mass_in_bed',&
        staggerloc=ESMF_STAGGERLOC_CENTER, &
        ungriddedLBound=(/1/),ungriddedUBound=(/nfrac/), &
        gridToFieldMap=(/1,2/), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field,'units', trim('kg m-2'),rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_FieldGet(field, rank=rank, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

!      call ESMF_AttributeSet(field,'missing_value',sed%missing_value,rc=localrc)
!      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      if (allocated(ubnd)) deallocate(ubnd)
      if (allocated(lbnd)) deallocate(lbnd)
      allocate(ubnd(rank))
      allocate(lbnd(rank))

      call ESMF_FieldGet(field=field, farrayPtr=sediment_mass, &
        exclusiveLBound=lbnd, exclusiveUbound=ubnd, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call MOSSCO_FieldInitialize(field, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      do j=1,jnum
        do i= 1,inum
          sediment_mass(lbnd(1)-1+i,lbnd(2)-1+j,1:nfrac) = mass(1:nfrac,inum*(j-1)+i)
        end do
      end do

      call ESMF_StateAddReplace(exportState,(/field/), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    end if

    if (allocated(ubnd)) deallocate(ubnd)
    if (allocated(lbnd)) deallocate(lbnd)

    ! Write a metadata state
    paramState=ESMF_StateCreate(stateIntent=ESMF_STATEINTENT_EXPORT, &
      name=trim(name), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    !call MOSSCO_AttributesCopy(paramState, exportState)
    !call MOSSCO_StateStateAttributesCopy(paramState, exportState)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_StateAddReplace(exportState, (/paramState/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call MOSSCO_CompExit(gridComp, localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine InitializeP1

#undef  ESMF_METHOD
#define ESMF_METHOD "InitializeP2"
  subroutine InitializeP2(gridComp, importState, exportState, clock, rc)
    implicit none

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    character(ESMF_MAXSTR)  :: name, message, format, string
    type(ESMF_Time)         :: currTime

    type(ESMF_Field), target     :: field
    type(ESMF_Grid)              :: grid
    type(ESMF_FieldStatus_Flag)  :: status
    integer(ESMF_KIND_I4)        :: localrc, i,j,l,n

    integer(ESMF_KIND_I4),target       :: coordDimCount(2),coordDimMap(2,2)
    integer(ESMF_KIND_I4),dimension(2) :: totalLBound,totalUBound
    integer(ESMF_KIND_I4),dimension(2) :: lbnd,ubnd

    real(ESMF_KIND_R8)                 :: external_d50
    integer(ESMF_KIND_I4)              :: external_index

    type :: allocatable_integer_array
      integer(ESMF_KIND_I4),dimension(:),allocatable :: data
    end type

    type(allocatable_integer_array) :: coordTotalLBound(2),coordTotalUBound(2)

    type(ESMF_Field)  ,dimension(:),allocatable    :: fieldlist, fluxFieldList
    type(ESMF_Field)  ,dimension(:),allocatable    :: spmFieldList
    type(ESMF_FieldBundle)                         :: fieldBundle
    integer(ESMF_KIND_I4)                          :: fieldCount

    real(ESMF_KIND_R8),dimension(:,:)  ,pointer    :: ptr_f2=>null()
    integer(ESMF_KIND_I8),dimension(:),allocatable :: spm_flux_id
    logical :: isPresent
    character(len=ESMF_MAXSTR), allocatable        :: options(:)

    call MOSSCO_CompEntry(gridComp, clock, name=name, currTime=currTime, &
      importState=importState, exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

!   Get the total domain size from the coordinates associated with the Grid
    call ESMF_GridCompGet(gridComp, grid=grid, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridGet(grid, ESMF_STAGGERLOC_CENTER, localDe=0, &
      exclusiveLBound=lbnd, exclusiveUBound=ubnd, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridGet(grid, coordDimCount=coordDimCount, &
      coordDimMap=coordDimMap, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    do i=1,2
      allocate(coordTotalLBound(i)%data(coordDimCount(i)))
      allocate(coordTotalUBound(i)%data(coordDimCount(i)))
      call ESMF_GridGetCoordBounds(grid, coordDim=i,                     &
                                   totalLBound=coordTotalLBound(i)%data, &
                                   totalUBound=coordTotalUBound(i)%data)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      do j=1,coordDimCount(i)
        if (coordDimMap(i,j) .eq. i) then
          totalLBound(i) = coordTotalLBound(i)%data(j)
          totalUBound(i) = coordTotalUBound(i)%data(j)
          exit
        end if
      end do
    end do

    call ESMF_GridGetItem(grid, ESMF_GRIDITEM_MASK, isPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (isPresent) then
      call ESMF_GridGetItem(grid, ESMF_GRIDITEM_MASK, farrayPtr=mask, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    else
      allocate(mask(RANGE2D))
      mask = 1
    endif

  !> The mass calculation should *not* consider area, but mass per area, such
  !> that fluxes can be budgeted
   ! call ESMF_GridGetItem(grid, ESMF_GRIDITEM_AREA,                  &
   !                       staggerloc=ESMF_STAGGERLOC_CENTER, &
   !                       isPresent=isPresent, rc=localrc)
   ! _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
   !
   ! if (isPresent) then
   !    call ESMF_GridGetItem(grid, ESMF_GRIDITEM_AREA,                  &
   !                          staggerloc=ESMF_STAGGERLOC_CENTER, &
   !                          farrayPtr=area, rc=localrc)
   !    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
   ! else
     allocate(area(RANGE2D))
     area = 1.0
   ! end if

   if (bedmodel) then
     do l=1,nfrac
       do j=1,jnum
         do i = 1, inum
           mass (l,inum*(j-1)+i) = init_thick * area (lbnd(1)-1+i,lbnd(2)-1+j) &
             * (1.0-porosity) * rhosol(l) * frac (l,inum*(j-1)+i)
         enddo
       enddo
     enddo
   endif

  !> Options for printing field information with MOSSCO_FieldString
  allocate(options(5))
  options(:)=(/'creator','bounds ','geom   ','loc    ','mean   '/)

  ! Complete Import Fields
  do i = 1, ubound(importList,1)
      call ESMF_StateGet(importState, trim(importList(i)%name), field, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_FieldGet(field, status=status, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (status .eq. ESMF_FIELDSTATUS_GRIDSET) then

        if ( importList(i)%optional ) cycle

        write(message, '(A)') trim(name)//' import from internal  '
        call MOSSCO_FieldString(field, message, options=options, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

        allocate(importList(i)%data(RANGE2D), stat=localrc)

        call ESMF_FieldEmptyComplete(field, importList(i)%data, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        importList(i)%data = 0.0d0

      elseif (status .eq. ESMF_FIELDSTATUS_COMPLETE) then

        write(message, '(A)') trim(name)//' import from external  '
        call MOSSCO_FieldString(field, message, options=options)
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

        call ESMF_FieldGet(field, farrayPtr=importList(i)%data, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (.not. (    (      all(lbound(importList(i)%data) .eq. totalLBound    )           &
                        .and. all(ubound(importList(i)%data) .eq. totalUBound    ) )         &
                   .or.(      all(lbound(importList(i)%data) .eq. lbnd)           &
                        .and. all(ubound(importList(i)%data) .eq. ubnd) ) ) ) then

          write(message, '(A)') trim(name)//' invalid bounds '
          call MOSSCO_FieldString(field, message, options=options)
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
          call ESMF_Finalize(endflag=ESMF_END_ABORT)
        end if
      else
        write(message, '(A)') trim(name)//' erroneously obtained empty '
        call MOSSCO_FieldString(field, message)
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
        call ESMF_Finalize(endflag=ESMF_END_ABORT)
      end if
  end do

  !> first try to get "external_index" from "concentration_of_SPM" fieldBundle in import State
  call ESMF_StateGet(importState, 'concentration_of_SPM_in_water', &
    fieldBundle, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_FieldBundleGet(fieldBundle, fieldCount=fieldCount, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (fieldCount==1 .and. nfrac>1) then
      write(message,'(A)') trim(name)//' mapped all fractions to one SPM fraction.'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
      external_idx_by_nfrac(:)=1
  elseif (nfrac==1 .and. fieldCount>1) then
      write(message,'(A)') trim(name)//' cannot map 1 fraction to multiple SPM fractions, yet.'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  elseif (nfrac /= 0 .and. fieldCount ==0) then
      write(message,'(A)') trim(name)//'initial values from sedparams.txt will be used for sediment parameters.'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      do i = 1, nfrac
        external_idx_by_nfrac(i)=i
      end do
  elseif (nfrac /= fieldCount) then
      write(format, '(A)') '(A,'//intformat(fieldCount)//',A,'//intformat(nfrac)//',A)'
      write(message, format) trim(name)//' cannot map ', fieldCount, &
        ' fields to ', nfrac,' SPM fractions'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  else ! nfrac == fieldCount

    if (allocated(spmFieldList) .and. size(spmFieldList) /= fieldcount) deallocate(spmFieldList)
    if (.not.allocated(spmFieldList)) allocate(spmFieldList(fieldCount))

    call ESMF_FieldBundleGet(fieldBundle, FieldList=spmFieldList, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    do n=1, nfrac

      call ESMF_AttributeGet(spmFieldList(n),'external_index', &
        isPresent=isPresent, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (isPresent) then
        call ESMF_AttributeGet(spmFieldList(n), 'external_index', &
          external_idx_by_nfrac(n), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      else
        write(message,'(A,I1,A,I1)') trim(name)// &
          ' no external index attribute found for SPM fraction //', n
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
        external_idx_by_nfrac(n)=n
      endif
    end do
  endif

  !! after having external_index defined by nfrac, create nfrac_by_external_idx:
  allocate(nfrac_by_external_idx(1:maxval(external_idx_by_nfrac)))
  do n=1,ubound(external_idx_by_nfrac,1)
    nfrac_by_external_idx(external_idx_by_nfrac(n))=n
  end do


  call ESMF_StateGet(exportState, &
    'concentration_of_SPM_upward_flux_at_soil_surface', fieldBundle,rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_FieldBundleGet(fieldBundle, fieldCount=fieldCount, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (fieldcount .gt. 0) then

    allocate(fluxFieldList(fieldCount))
    allocate(spm_flux_id(fieldCount))

    call ESMF_FieldBundleGet(fieldBundle, fieldList=fluxFieldList, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    do i=1,fieldCount
      call ESMF_AttributeGet(fluxFieldList(i), 'external_index', value=spm_flux_id(i), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    end do
  end if

  do n=1, nfrac

    i = -1
    do j=1, fieldCount
      if (spm_flux_id(j) .eq. external_idx_by_nfrac(n) ) then
        i = j
        exit
      end if
    end do

    if (i .ne. -1) then
      write(message,'(A,I2,A,ES9.3)') trim(name)// &
        ' maps fraction ',i, ' with mean diameter ',sedd50(i)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      write(message,'(A)') trim(name)//'   to '
      call MOSSCO_FieldString(fluxFieldList(j), message)
      write(message,'(A)') ' with unknown density'

      call ESMF_AttributeGet(spmFieldList(j), 'mean_particle_diameter', &
        isPresent=isPresent, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (isPresent) then
        call ESMF_AttributeGet(spmFieldList(j), 'mean_particle_diameter', &
          value=external_d50, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        write(string,'(A,ES9.3)') ' with density ',external_d50
        call MOSSCO_MessageAdd(message, string)

        call ESMF_AttributeSet(fluxFieldList(j), 'mean_particle_diameter', &
          value=external_d50, rc=localrc)
      endif
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

      call ESMF_AttributeSet(fluxFieldList(j), 'erosed_fraction', &
        value=n, rc=localrc)

      call ESMF_FieldGet(fluxFieldList(i), status=status, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (status .eq. ESMF_FIELDSTATUS_COMPLETE) then

        call ESMF_FieldGet(fluxFieldList(i), &
          farrayPtr=size_classes_of_upward_flux_of_pim_at_bottom(n)%ptr, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (.not. ( all(lbound(size_classes_of_upward_flux_of_pim_at_bottom(n)%ptr) .eq. (/   1,   1/) ) &
          .and. all(ubound(size_classes_of_upward_flux_of_pim_at_bottom(n)%ptr) &
          .eq. (/inum,jnum/) ) ) ) then
          call ESMF_LogWrite('invalid field bounds',ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
          call ESMF_Finalize(endflag=ESMF_END_ABORT)
        end if
      else !> Field not complete
        call ESMF_LogWrite('incomplete field',ESMF_LOGMSG_ERROR,ESMF_CONTEXT)
        call ESMF_Finalize(endflag=ESMF_END_ABORT)
      end if
    else ! i== -1

      write(message,'(A)') trim(name)//' exports to internal field '// &
        'concentration_of_SPM_upward_flux_at_soil_surface'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

      !> @todo This allocation might be critical if the field has totalwidth (halo zones)
      !>        We might have to allocate with these halo zones (not until we get into trouble)
      allocate (size_classes_of_upward_flux_of_pim_at_bottom(n)%ptr(inum, jnum))
      do j=1,jnum
        do i= 1, inum
          size_classes_of_upward_flux_of_pim_at_bottom(n)%ptr(i,j) = sink(n,inum*(j -1)+i)-sour(n,inum*(j -1)+i)
        end do
      end do
      ptr_f2 => size_classes_of_upward_flux_of_pim_at_bottom(n)%ptr

      field = ESMF_FieldCreate(grid, farrayPtr=ptr_f2, &
        name='concentration_of_SPM_upward_flux_at_soil_surface', rc=localrc)
      call ESMF_AttributeSet(field, 'external_index', external_idx_by_nfrac(n), &
        rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      nullify(ptr_f2) !we don't need it anymore

      call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      write(message,'(A)') trim(name)//' created bundled '
      call MOSSCO_FieldString(field, message, options=options, rc=localrc)
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

      call ESMF_FieldBundleAdd(fieldBundle,(/field/),multiflag=.true.,rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    end if

  end do !> Loop over erosed fractions 1..nfrac

  !> Add metadata from erosed to fields in export State
  call ESMF_StateGet(exportState, &
    'concentration_of_SPM_upward_flux_at_soil_surface', fieldBundle,rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_FieldBundleGet(fieldBundle, fieldCount=fieldCount, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (fieldCount > 0) then
    call ESMF_FieldBundleGet(fieldBundle, fieldList=fluxFieldList, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif

  ! do i=1, fieldCount
  !   field = fluxFieldList(i)
  !   call ESMF_AttributeGet(field, 'external_index', external_index, rc=localrc)
  !   n = int(nfrac_by_external_idx(external_index),kind=ESMF_KIND_I4)
  !
  !   if (sedtyp(n) == 1) call ESMF_AttributeSet(field, 'sediment_type', 'noncohesive', rc=localrc)
  !   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  !   if (sedtyp(n) == 2) call ESMF_AttributeSet(field, 'sediment_type', 'cohesive', rc=localrc)
  !   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  !
  !   call ESMF_AttributeSet(field, 'dry_bed_density', cdryb(n), rc=localrc)
  !   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  !   call ESMF_AttributeSet(field, 'specific_density', rhosol(n), rc=localrc)
  !   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  !   call ESMF_AttributeSet(field, 'particle_diameter_q50', sedd50(n), rc=localrc)
  !   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  !   call ESMF_AttributeSet(field, 'particle_diameter_q90', sedd90(n), rc=localrc)
  !   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  !   call ESMF_AttributeSet(field, 'mud_erosion_parameter', eropar(n,1), rc=localrc)
  !   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  !
  ! enddo

    !> @todo This allocation might be critical if the field has totalwidth (halo zones)
    !>        We might have to allocate with these halo zones (not until we get into trouble)
    allocate (rms_orbital_velocity%ptr(inum, jnum))

    rms_orbital_velocity%ptr(:,:)= 0.0_fp

    field = ESMF_FieldCreate(grid, farrayPtr=rms_orbital_velocity%ptr, &
      name='rms_orbital_velocity_at_soil_surface', rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(message,'(A)') trim(name)//' created for export '
    call MOSSCO_FieldString(field, message, options=options, rc=localrc)
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    call ESMF_StateAddReplace(exportState,(/field/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    !> @todo This allocation might be critical if the field has totalwidth (halo zones)
    !>        We might have to allocate with these halo zones (not until we get into trouble)

    !> Bottom shear stress for cohesive sediments
    if (any(sedtyp(1:nfrac) == 2)) then

      allocate (bottom_shear_stress%ptr(inum,jnum))
      bottom_shear_stress%ptr(:,:)= 0.0_fp

      field = ESMF_FieldCreate(grid, &
        farrayPtr=bottom_shear_stress%ptr, &
        name='shear_stress_cohesive_at_soil_surface', rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      write(message,'(A)') trim(name)//' created for export '
      call MOSSCO_FieldString(field, message, options=options, rc=localrc)
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

      call ESMF_StateAddReplace(exportState,(/field/), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    endif

    !> Bottom shear stress for non-cohesive sediments
    if (any(sedtyp(1:nfrac) == 1)) then

      allocate (bottom_shear_stress_noncohesive%ptr(inum,jnum))
      bottom_shear_stress_noncohesive%ptr(:,:)= 0.0_fp

      field = ESMF_FieldCreate(grid, &
        farrayPtr=bottom_shear_stress_noncohesive%ptr, &
        name='shear_stress_noncohesive_at_soil_surface', rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field,'creator', trim(name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      write(message,'(A)') trim(name)//' created for export '
      call MOSSCO_FieldString(field, message, options=options, rc=localrc)
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

      call ESMF_StateAddReplace(exportState,(/field/), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    endif

    allocate (equilibrium_spm%ptr(inum, jnum))

    equilibrium_spm%ptr(:,:)= 0.0_fp

    field = ESMF_FieldCreate(grid, farrayPtr=equilibrium_spm%ptr, &
      name='Equilibrium_SPM_concentration_at_soil_surface_noncohesive', rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_AttributeSet(field,'creator', trim(name), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(message,'(A)') trim(name)//' created for export '
    call MOSSCO_FieldString(field, message, options=options, rc=localrc)
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    call ESMF_StateAddReplace(exportState,(/field/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

!#ifdef DEBUG

    field = ESMF_FieldCreate(grid, &
                         typekind=ESMF_TYPEKIND_R8, &
                         name='depth_average_concentration_of_SPM_in_water',&
                         staggerloc=ESMF_STAGGERLOC_CENTER, &
                         ungriddedLBound=(/1/),ungriddedUBound=(/nfrac/), &
                         gridToFieldMap=(/1,2/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(message,'(A)') trim(name)//' created for export '
    call MOSSCO_FieldString(field, message, options=options, rc=localrc)
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
    call ESMF_AttributeSet(field,'units','g.m-3',rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
!   call ESMF_AttributeSet(field,'missing_value',sed%missing_value,rc=localrc)
!   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    call ESMF_FieldGet(field=field, farrayPtr=depth_avg_spm_concentration,rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    depth_avg_spm_concentration(:,:,:)= 0.0_fp

    call ESMF_StateAddReplace(exportState,(/field/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    sum_depth_avg_spm_concentration(:,:) =0.0_fp

    field = ESMF_FieldCreate(grid, farrayPtr=sum_depth_avg_spm_concentration, &
        name='Sum_depth_average_concentration_of_SPM_in_water', rc=localrc)
    call ESMF_AttributeSet(field,'creator', trim(name), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    write(message,'(A)') trim(name)//' created for export'
    call MOSSCO_FieldString(field, message, options=options, rc=localrc)
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    call ESMF_AttributeSet(field,'units',trim('g.m-3'),rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_StateAddReplace(exportState,(/field/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    deallocate(options)

    call MOSSCO_CompExit(gridComp, localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine InitializeP2

#undef  ESMF_METHOD
#define ESMF_METHOD "ReadRestart"
  subroutine ReadRestart(gridComp, importState, exportState, parentClock, rc)

    type(ESMF_GridComp)   :: gridComp
    type(ESMF_State)      :: importState
    type(ESMF_State)      :: exportState
    type(ESMF_Clock)      :: parentClock
    integer, intent(out)  :: rc

    integer(ESMF_KIND_I4) :: localrc, i, j, n, fieldCount
    logical               :: isPresent
    type(ESMF_Clock)      :: clock
    type(ESMF_Time)       :: currTime
    character(len=ESMF_MAXSTR) :: message, name

    type(ESMF_Field), dimension(:), allocatable :: exportFieldList, importFieldList
    integer(ESMF_KIND_I4)                       :: importFieldCount, exportFieldCount
    integer(ESMF_KIND_I4)                       :: rank
    integer(ESMF_KIND_I4), dimension(:), allocatable  :: ubnd, lbnd
    real(ESMF_KIND_R8), dimension(:,:,:), pointer :: farrayPtr3 => null()
    real(ESMF_KIND_R8), dimension(:,:), pointer   :: farrayPtr2 => null()
    real(ESMF_KIND_R8), dimension(nfrac)          :: total_mass, diff_mass
    real(ESMF_KIND_R8)                            :: total_sediment_mass

    rc=ESMF_SUCCESS

    call MOSSCO_CompEntry(gridComp, clock, name=name, currTime=currTime, &
      importState=importState, exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    ! Restart in this component is relevant only for the sediment mass,
    ! Currently, this is a 2D gridded field with an additional 3rd dimension
    ! to describe the nfrac sediment fractions
    !> @todo possibly read fieldBundle of 2D fields
    !> @todo possibly read 2D field and partition reasonably

    call MOSSCO_StateGetFieldList(importState, importFieldList, fieldCount=importFieldCount, &
      itemSearch='sediment_mass_in_bed', &
      fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (importFieldCount < 1) then
      write(message, '(A)') trim(name)//' did not hotstart'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      if (allocated(importFieldList)) deallocate(importFieldList)
      call MOSSCO_CompExit(gridComp, localrc)
      return
    endif

    if (importFieldCount > 1) then
      write(message, '(A)') trim(name)//' cannot handle more than one field with sediment mass yet'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      if (allocated(importFieldList)) deallocate(importFieldList)
      call MOSSCO_CompExit(gridComp, localrc)
      rc = ESMF_RC_NOT_IMPL
      return
    endif

    call ESMF_FieldGet(importFieldList(1), rank=rank, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (rank /= 3) then
      write(message, '(A,I1)') trim(name)//' cannot yet handle field with rank ',rank
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      if (allocated(importFieldList)) deallocate(importFieldList)
      call MOSSCO_CompExit(gridComp, localrc)
      rc = ESMF_RC_NOT_IMPL
      return
    endif

    allocate(ubnd(rank), stat=localrc)
    allocate(lbnd(rank), stat=localrc)

    call ESMF_FieldGet(importFieldList(1), farrayPtr=sediment_mass, &
      exclusiveLBound=lbnd, exclusiveUBound=ubnd, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    total_sediment_mass = 0.0

    do n=1,nfrac
      total_sediment_mass =  total_sediment_mass &
        + sum(sediment_mass(RANGE2D,n), mask=mask(RANGE2D)>0)
    enddo
  !   do n=1,nfrac
  !   do j=1,jnum
  !     do i=1,inum
  !       if (mask(lbnd(1)-1+i,lbnd(2)-1+j)>0) then
  !          total_sediment_mass = total_sediment_mass + sediment_mass(lbnd(1)-1+i,lbnd(2)-1+j,n)
  !       endif
  !     end do
  !   end do
  ! enddo

    write(message, '(A)') trim(name)//' restarting from '
    call MOSSCO_FieldString(importFieldList(1), message)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

    write(message, '(A,ES10.3)') trim(name)//' total restarteable bed mass is ', &
      total_sediment_mass
    call MOSSCO_FieldUnitString(importFieldList(1), message)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

    mass(:,:) = 0.0
    do j=1,jnum
      do i=1,inum
        if (mask(lbnd(1)-1+i,lbnd(2)-1+j)>0) then
          !> @todo we should not add but merely copy sediment_mass into mass
          mass(1:nfrac,inum*(j-1)+i) = & !mass(1:nfrac,inum*(j-1)+i) &
            + sediment_mass(lbnd(1)-1+i,lbnd(2)-1+j,1:nfrac)
        endif
      end do
    end do

    do n=1,nfrac
      total_mass(n) = sum(mass(n,:))

      write(message, '(A,I2,A,ES10.3)') trim(name)//' restarted bed mass in fraction', &
        n, ' is ', total_mass(n)
      call MOSSCO_FieldUnitString(importFieldList(1), message)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
    enddo

    call MOSSCO_StateGetFieldList(exportState, exportFieldList, fieldCount=exportFieldCount, &
      itemSearch='sediment_mass_in_bed', &
      fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (exportFieldCount < 1) then
      write(message, '(A)') trim(name)//' could not find field sediment_mass_in_bed'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      if (allocated(exportFieldList)) deallocate(exportFieldList)
      call MOSSCO_CompExit(gridComp, localrc)
      rc = ESMF_RC_NOT_IMPL
      return
    endif

    if (exportFieldCount > 1) then
      write(message, '(A)') trim(name)//' cannot handle more than one field with sediment mass'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      if (allocated(exportFieldList)) deallocate(exportFieldList)
      call MOSSCO_CompExit(gridComp, localrc)
      rc = ESMF_RC_NOT_IMPL
      return
    endif

    !> @todo check why this does not work
    !call MOSSCO_FieldCopy(exportfieldList(1), importFieldList(1), rc=localrc)
    !_MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_FieldGet(exportfieldList(1), farrayPtr=farrayPtr3, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    do n = 1,nfrac
      where(mask(RANGE2D) > 0)
        farrayPtr3(RANGE2D,n) = sediment_mass(RANGE2D, n)
      endwhere
    enddo

    do n=1,nfrac
      diff_mass(n) = total_mass(n) - &
        sum(farrayPtr3(RANGE2D,n), mask=mask(RANGE2D)>0)
        write(0,*) 'diff_mass', n, diff_mass(n)
        write(0,*) 'tot_mass',  total_mass(n), sum(farrayPtr3(RANGE2D,n), mask=mask(RANGE2D)>0)
        write(message, '(A,I2,A,ES10.3)') trim(name)//' exported bed mass in fraction', &
          n, ' is ', sum(farrayPtr3(RANGE2D,n), mask=mask(RANGE2D)>0)
        call MOSSCO_FieldUnitString(exportFieldList(1), message)
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
    enddo

    if (allocated(exportFieldList)) deallocate(exportFieldList)
    if (allocated(importFieldList)) deallocate(importFieldList)
    if (allocated(ubnd)) deallocate(ubnd)
    if (allocated(lbnd)) deallocate(lbnd)

    call MOSSCO_CompExit(gridComp, localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine ReadRestart

#undef  ESMF_METHOD
#define ESMF_METHOD "Run"
subroutine Run(gridComp, importState, exportState, parentClock, rc)

  type(ESMF_GridComp)      :: gridComp
  type(ESMF_State)         :: importState, exportState
  type(ESMF_Clock)         :: parentClock
  integer, intent(out)     :: rc

  type(ESMF_Time)          :: stopTime
  type(ESMF_TimeInterval)  :: timestep
  type(ESMF_Grid)          :: grid
  integer(ESMF_KIND_I8)    :: advancecount
  real(ESMF_KIND_R8)       :: runtimestepcount,dt

  real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: depth=>null()
  real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: u2d=>null(),v2d=>null()
  real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: nybot=>null()
  real(kind=ESMF_KIND_R8),dimension(:,:)  ,pointer :: taubmax=>null()
  real(kind=ESMF_KIND_R8),dimension(:,:)  ,pointer :: waveH=>null(),waveT=>null()
  real(kind=ESMF_KIND_R8),dimension(:,:)  ,pointer :: waveK=>null(),waveDir=>null()
  real(kind=ESMF_KIND_R8),dimension(:,:)  ,pointer :: microEro=>null(),microTau=>null()
  real(kind=ESMF_KIND_R8),dimension(:,:)  ,pointer :: macroEro=>null(),macroTau=>null()
  real(kind=ESMF_KIND_R8),dimension(:,:,:),pointer :: ptr_f3=>null()

  type(ESMF_Field)         :: Microphytobenthos_erodibility, Microphytobenthos_critical_bed_shearstress
  type(ESMF_Field)         :: Macrofauna_erodibility,Macrofauna_critical_bed_shearstress
  integer(ESMF_KIND_I4)    :: n, i, j, k,l, localrc, istat,nm, fieldCount
  type(ESMF_Field)         :: field
  type(ESMF_Field),dimension(:),allocatable :: fieldlist
  type(ESMF_FieldBundle)   :: fieldBundle
  logical                  :: forcing_from_coupler=.true.
  real(kind=ESMF_KIND_R8),parameter :: ws_convention_factor=-1.0 !upward positive

  integer                  :: petCount, localPet
  character(ESMF_MAXSTR)   :: name, message
  logical                  :: isPresent
  type(ESMF_Time)          :: currTime, nextTime
  type(ESMF_Clock)         :: clock
  integer(ESMF_KIND_I8)    :: external_index
  logical                  :: First_entry = .true.

  type(ESMF_StateItem_Flag) :: itemType
  type(ESMF_FieldStatus_Flag) :: status
  integer,dimension(2)     :: totalLBound,totalUBound
  integer,dimension(2)     :: exclusiveLBound,exclusiveUBound
  integer,dimension(3)     :: exclusiveLBound3,exclusiveUBound3,totalLBound3,totalUBound3
  integer(ESMF_KIND_I4)    :: ubnd(3), lbnd(3), tubnd(3), tlbnd(3)
  integer(ESMF_KIND_I4)    :: ifubnd(3), iflbnd(3)
  integer                  :: kmx, kmaxsd, knum !(kmaxsd: kmax-layer index for sand)
  real (kind=fp) :: deposition_rate, entrainment_rate

  real(ESMF_KIND_R8)                  :: external_d50, real8
  character(len=ESMF_MAXSTR), pointer :: includeList(:) => null()
  logical                             :: verbose = .false.
  real(ESMF_KIND_R8), dimension(:,:,:), allocatable :: mass_in_spm, mass_total
  real(ESMF_KIND_R8), dimension(:,:,:), allocatable :: mass_in_bed

  type(ESMF_Field),dimension(:),allocatable :: spmFieldlist, fluxFieldList
  type(ESMF_Field),dimension(:),allocatable :: velFieldlist
  character(len=ESMF_MAXSTR)                :: string
  real(ESMF_KIND_R8), allocatable           :: farray1(:)

  rc = ESMF_SUCCESS

  call MOSSCO_CompEntry(gridComp, parentClock, name=name, currTime=currTime, &
    importState=importState, exportState=exportState, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_GridCompGet(gridComp, petCount=petCount, localPet=localPet, &
    clock=clock, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_ClockGet(clock, currTime=currTime, advanceCount=advanceCount, &
    runTimeStepCount=runTimeStepCount, timeStep=timeStep, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (advanceCount < 2 ) verbose = .true.

  call ESMF_ClockGetNextTime(parentclock, nextTime, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  timestep=nextTime-currtime

  call ESMF_TimeIntervalGet(timestep, s_r8=dt, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call MOSSCO_StateGet(exportState, fieldList, fieldCount=fieldCount, &
    itemSearch='sediment_mass_in_bed', &
    fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/), rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (fieldCount > 0) then
    call ESMF_fieldGet(fieldList(1), farrayPtr=sediment_mass, exclusiveLBound=lbnd, &
      exclusiveUBound=ubnd, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    allocate(mass_in_bed(RANGE3D))
    allocate(mass_in_spm(RANGE3D))
    allocate(mass_total(RANGE3D))

    mass_in_bed(RANGE3D)=sediment_mass(RANGE3D)
  endif

  if (associated(includeList)) deallocate(includeList)
  allocate(includeList(1))
  includeList(1)='concentration_of_SPM_in_water'

  call MOSSCO_StateGet(importState, spmFieldList, fieldCount=fieldCount, &
    include=includeList, &
    fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/), rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (fieldCount == 0) then
    write(message, '(A)') trim(name)//' did not find '//trim(includelist(1)), &
      ', runs without pelagic forcing'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

    h0=h1

  elseif (fieldCount /= nfrac) then
    write(message, '(A)') trim(name)//' obtained wrong number of SPM fractions'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    localrc = ESMF_RC_ARG_BAD
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif

  includeList(1)='concentration_of_SPM_z_velocity_in_water'
  call MOSSCO_StateGet(importState, velFieldList, fieldCount=fieldCount, &
    include=includeList, &
    fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/), rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (fieldCount > 0 .and. fieldCount /= nfrac) then
    write(message, '(A)') trim(name)//' obtained wrong number of SPM velocity fractions'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    localrc = ESMF_RC_ARG_BAD
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif

  includeList(1)='concentration_of_SPM_upward_flux_at_soil_surface'
  call MOSSCO_StateGet(exportState, fluxFieldList, fieldCount=fieldCount, &
    include=includeList, &
    fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/), rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (fieldCount > 0 .and. fieldCount /= nfrac) then
    write(message, '(A)') trim(name)//' obtained wrong number of SPM flux fractions'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    localrc = ESMF_RC_ARG_BAD
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif

  write(message,'(A)') trim(name)// ' maps '
  do i=1, fieldCount
    call ESMF_AttributeGet(spmFieldList(i), 'external_index', &
      value=external_index,  rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(string, '(A,I1,A,I1)') ' (',i,') ',external_index
    call ESMF_AttributeGet(velFieldList(i), 'external_index', &
      value=external_index, &
      rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(string, '(A,X,I1)') trim(string), external_index

    call ESMF_AttributeGet(fluxFieldList(i),'external_index', external_index, &
      rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(string, '(A,X,I1,X,I1)') trim(string),external_index, &
      nfrac_by_external_idx(external_index)
    call MOSSCO_MessageAdd(message,string)
  end do
  if (verbose) call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

  !> Compare and consolidate attributes
  !> This should be done only once for performance
  do i=1, fieldCount

    call ESMF_AttributeGet(spmFieldList(i), 'mean_particle_diameter', &
      external_d50, rc=localrc)
    call ESMF_AttributeGet(velFieldList(i), 'mean_particle_diameter', &
      isPresent=isPresent, rc=localrc)
    if (isPresent) then
      call ESMF_AttributeGet(velFieldList(i), 'mean_particle_diameter', &
        real8, rc=localrc)
      if (abs(external_d50 - real8) > 10*tiny(real8)) then
        write(message ,'(A)') trim(name)//' obtained mismatching SPM info'
        rc = ESMF_RC_ARG_BAD
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      endif
    else
      call ESMF_AttributeSet(velFieldList(i), 'mean_particle_diameter', &
        external_d50, rc=localrc)
    endif

    call ESMF_AttributeGet(fluxFieldList(i), 'mean_particle_diameter', &
      isPresent=isPresent, rc=localrc)
    if (isPresent) then
      call ESMF_AttributeGet(fluxFieldList(i), 'mean_particle_diameter', &
        real8, rc=localrc)
      if (abs(external_d50 - real8) > 10*tiny(real8)) then
        write(message ,'(A)') trim(name)//' obtained mismatching SPM info'
        rc = ESMF_RC_ARG_BAD
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      endif
    else
      call ESMF_AttributeSet(fluxFieldList(i), 'mean_particle_diameter', &
        external_d50, rc=localrc)
    endif

    if (external_d50 - sedd50(nfrac_by_external_idx(external_index)) > 10*tiny(real8)) then
      write(message,'(A)') trim(name)//' particle diameter sizes do not agree in '
      call MOSSCO_FieldString(spmFieldList(i), message, rc=localrc)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
      !_MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      sedd50(nfrac_by_external_idx(external_index)) = external_d50
    endif

    call ESMF_AttributeGet(spmFieldList(i),'particle_density', &
      rhosol(nfrac_by_external_idx(external_index)), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    !> @todo copy over all other parameters from iow/spm model

  enddo


    !> @todo adjust this to meshes
    if (allocated(spmFieldList)) then

      call ESMF_FieldGet(spmFieldList(1), grid=grid,rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      !> Get the height/thickness of all layers in 3D grid and also
      !> get the depth of the interfaces
      call MOSSCO_GridGetDepth(grid, height=layer_thickness,  &
        interface=interface_height_above_soil_surface, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    endif


    !> get spm concentrations, particle sizes and density
    !> @todo better use MOSSCO_StateGet to fieldList
    call ESMF_StateGet(importState,'concentration_of_SPM_in_water', &
      fieldBundle, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_FieldBundleGet(fieldBundle, fieldCount=n, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (n .eq. 0) then
      !> run without SPM forcing from pelagic component
!#ifdef DEBUG
      call ESMF_LogWrite( &
         'field Bundle concentration_of_SPM not found, run without pelagic forcing', &
         ESMF_LOGMSG_INFO)
!#endif
    else

      if (allocated(fieldlist)) deallocate(fieldlist)
      allocate(fieldlist(n))

      call ESMF_FieldBundleGet(fieldBundle, fieldlist=fieldlist, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_FieldGet(fieldList(1), grid=grid,rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      !> Get the height/thickness of all layers in 3D grid and also
      !> get the depth of the interfaces
      call MOSSCO_GridGetDepth(grid, height=layer_thickness,  &
        interface=interface_height_above_soil_surface, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      do n=1, size(fieldlist)

        field = fieldlist(n)
        call ESMF_AttributeGet(field,'external_index', isPresent=isPresent, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (isPresent) then
          call ESMF_AttributeGet(field,'external_index',external_index, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        else
          write(message,'(A)')  trim(name)//' did not find "external_index" attribute in'
          call MOSSCO_FieldString(field, message, rc=localrc)
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
          external_index=1
          write (*,*) 'external_index is not present, therefore set to 1)'
        endif

        call ESMF_AttributeGet(field, 'mean_particle_diameter', isPresent=isPresent, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)


        call ESMF_AttributeGet(field,'particle_density', isPresent=isPresent, &
          rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        !> @too check equality and fail if not
        if (isPresent) then
          call ESMF_AttributeGet(field,'particle_density',rhosol(nfrac_by_external_idx(external_index)), rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        else
          rhosol(nfrac_by_external_idx(external_index))=0.0
          write(message,'(A)')  trim(name)//' did not find "rhosol" attribute in field. It has bee set to zero'
          call MOSSCO_FieldString(field, message, rc=localrc)
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
        endif

        call ESMF_FieldGet(field, farrayPtr=ptr_f3, exclusiveLBound=lbnd, &
          exclusiveUBound=ubnd, totalLBound=tlbnd, totalUBound=tubnd, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        knum=ubnd(3)-lbnd(3)+1
         !> @todo proper bounds checking with eLBound required here
!          if (.not. ( all(lbound(ptr_f3)== lbnd).and. all(ubound(ptr_f3)==ubnd ) ) ) then
!            write(message, '(A)') trim(name)//' invalid field bounds in field'
!            call MOSSCO_FieldString(field, message, rc=localrc)
!            call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
!            call ESMF_Finalize(endflag=ESMF_END_ABORT)
!          end if
!
!          if (.not. (all(lbound(ptr_f3)==tlbnd).and. all(ubound(ptr_f3)==tubnd) ) ) then
!            write(message, '(A)') trim(name)//' bounds do not match total domain in field'
!            call MOSSCO_FieldString(field, message, rc=localrc)
!            call ESMF_LogWrite(trim(message),ESMF_LOGMSG_WARNING)
!          end if

        !> @todo unclear which localrc is excpected here
        !write (0,*) 'shape of spm_concentration original', shape (ptr_f3)
        if (localrc == ESMF_SUCCESS) then
          spm_concentration(1:inum,1:jnum,1:knum,nfrac_by_external_idx(external_index)) = ptr_f3(RANGE3D)

          ! Calculated mass in each fraction in kg m -2
          mass_in_spm(RANGE2D, nfrac_by_external_idx(external_index)) = &
            sum(ptr_f3(RANGE3D)*layer_thickness(RANGE3D),dim=3) / 1000

          mass_total(RANGE2D, nfrac_by_external_idx(external_index)) = &
            mass_in_spm(RANGE2D,nfrac_by_external_idx(external_index)) +  &
            mass_in_bed(RANGE2D,nfrac_by_external_idx(external_index))

        else
          write(message,'(A,I2.2)') trim(name)//' cannot find SPM fraction ',n
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING, ESMF_CONTEXT)
        end if

      end do

      !> get sinking velocities
      call MOSSCO_StateGet(importState, fieldList, fieldCount=fieldCount, &
        itemSearch='concentration_of_SPM_z_velocity_in_water', &
        fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/),  rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      do n=1,fieldCount

        call ESMF_FieldGet(fieldlist(n), farrayPtr=ptr_f3,rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_AttributeGet(fieldlist(n),'external_index',isPresent=isPresent, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (.not.isPresent) then
          write(message,'(A)') trim(name)//' external_index attribute is missing from field '
          call MOSSCO_FieldString(fieldList(n), message)
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
          external_index = n
        else
          call ESMF_AttributeGet(fieldlist(n),'external_index',external_index, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        endif

        do j=1,jnum
          do i= 1, inum
            ! filtering missing values (land)
            if ( mask(lbnd(1)-1+i,lbnd(2)-1+j) .gt. 0 ) then
             ws(nfrac_by_external_idx(external_index),inum*(j-1)+i) &
               = ptr_f3(lbnd(1)-1+i,lbnd(2)-1+j,1)
             else
               ws(nfrac_by_external_idx(external_index),inum*(j-1)+i) = 0.0_fp
             endif
          end do
        end do
      end do
    end if

  nullify(ptr_f3)
!-----

  !> Test for vertical CFL

  call map_variable(importState, 'layer_height_at_soil_surface', farray1, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (any(maxval(-ws,dim=1)*dt*2 > farray1 .and. farray1>0)) then
    write(message, '(A)') trim(name)//' coupling exceeds CFL, reduce coupling time step'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
    write(message, '(A,ES10.3)') trim(name)//' dt*ws/layerheight ',dt*maxval(maxval(-ws,dim=1)/farray1,mask=farray1>0)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
  endif

  !> Get water depth, assum initial water depth as default
  h1 = h0
  call map_variable(importState, 'water_depth_at_soil_surface', h1, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call map_variable(importState, 'x_velocity_at_soil_surface', u_bot, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call map_variable(importState, 'y_velocity_at_soil_surface', v_bot, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)


  if (wave) then
    call map_variable(importState, 'wave_period', tper, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    call map_variable(importState, 'wave_direction', teta, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif

  !> @todo clean up this list
  depth    => importList( 1)%data ! used in wave calc
  u2d      => importList( 3)%data
  v2d      => importList( 4)%data
  nybot    => importList( 7)%data
  taubmax  => importList( 8)%data

  microTau => importList( 9)%data
  microEro => importList(10)%data
  macroTau => importList(11)%data
  macroEro => importList(12)%data

  if (wave) then
    waveH   => importList(13)%data
    waveT   => importList(14)%data
    waveK   => importList(15)%data
    waveDir => importList(16)%data
  end if

  if (localrc == 0) then
    do j=1,jnum
      do i= 1, inum
        if ( mask(lbnd(1)-1+i,lbnd(2)-1+j) .gt. 0 ) then
          h1(inum*(j -1)+i) = depth(i,j)
        endif   ! else use initial value in phase 1
      end do
    end do
  else
    h1=h0
  endif

  if (first_entry) then
    h0 = h1
    first_entry = .false.
  end if

  call ESMF_GridGetCoordBounds(grid, coordDim=3, &
    staggerloc=ESMF_STAGGERLOC_CENTER, &
    exclusiveLBound=lbnd, exclusiveUbound=ubnd, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_GridGetCoordBounds(grid, coordDim=3, &
    staggerloc=ESMF_STAGGERLOC_CENTER_VFACE, &
    exclusiveLBound=iflbnd, exclusiveUbound=ifubnd, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (.not. associated (relative_layer_thickness)) then
    allocate (relative_layer_thickness(RANGE3D), stat=istat)

    if (istat /= 0) then
      write(message,'(A)') trim(name)//' cannot allocate memory for relative_layer_thickness'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      call MOSSCO_CompExit(gridComp, localrc)
      rc = ESMF_RC_MEM_ALLOCATE
      return
    end if
  endif

  if (.not. associated (sigma_midlayer)) then
    allocate (sigma_midlayer  (RANGE3D), stat = istat)

    if (istat /= 0) then
      write(message,'(A)') trim(name)//' cannot allocate memory for mid_layer'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      call MOSSCO_CompExit(gridComp, localrc)
      rc = ESMF_RC_MEM_ALLOCATE
      return
    end if
endif

  !> @todo Why do we allow localrc /= 0? (if there is no grid?)
  if (localrc == 0) then

    do k = 0,ubnd(3)-lbnd(3)

      layer_thickness(RANGE2D,lbnd(3)+k) &
        = interface_height_above_soil_surface(RANGE2D,iflbnd(3)+k+1) &
        - interface_height_above_soil_surface(RANGE2D,iflbnd(3)+k)

      relative_layer_thickness(RANGE2D,lbnd(3)+k) &
        =  layer_thickness(RANGE2D,lbnd(3)+k) &
        / (interface_height_above_soil_surface(RANGE2D,ifubnd(3)) - interface_height_above_soil_surface(RANGE2D,iflbnd(3)))
    end do

    do k = ubnd(3),1,-1
      if (k == ubnd(3)) then
        sigma_midlayer(RANGE2D,ubnd(3)) = -0.5_fp &
          *  relative_layer_thickness(RANGE2D,ubnd(3))
      else
        sigma_midlayer(RANGE2D,k) = sigma_midlayer(RANGE2D,k+1) - 0.5_fp &
          * (relative_layer_thickness(RANGE2D,k) &
          + relative_layer_thickness(RANGE2D,k+1) )
      endif
    end do

    do j=1,jnum
        do i= 1, inum
         ! filtering missing values (land)
         if ( mask(lbnd(1)-1+i,lbnd(2)-1+j) .gt. 0 ) then
          umod  (inum*(j -1)+i) = sqrt( u2d(i,j)*u2d(i,j) + v2d(i,j)*v2d(i,j) )

          !u_bot (inum*(j -1)+i) = ubot (i,j)
          !v_bot (inum*(j -1)+i) = vbot (i,j)
          if (wave) then
              tper (inum*(j -1)+i) = waveT (i,j)
              teta (inum*(j -1)+i) = WaveDir (i,j)
              uorb (inum*(j -1)+i) = CalcOrbitalVelocity (waveH(i,j), waveK(i,j), waveT(i,j), depth (i,j))
          endif

         else
          u2d(i,j) = 0.0_fp
          v2d(i,j) = u2d(i,j)
        end if
      end do
    end do

  else
    umod = 0.2
  end if

!-------

  !> get bio effects
  BioEffects%ErodibilityEffect = 1.0_fp
  if ( associated(microEro) ) BioEffects%ErodibilityEffect = BioEffects%ErodibilityEffect * microEro(1:inum,1:jnum)
  if ( associated(macroEro) ) BioEffects%ErodibilityEffect = BioEffects%ErodibilityEffect * macroEro(1:inum,1:jnum)

  BioEffects%TauEffect = 1.0_fp
  if ( associated(microTau) ) BioEffects%TauEffect = BioEffects%TauEffect * microTau(1:inum,1:jnum)
  if ( associated(macroTau) ) BioEffects%TauEffect = BioEffects%TauEffect * macroTau(1:inum,1:jnum)

 ! filtering missing values (land)
  do j = 1, jnum
    do i = 1, inum
      if (mask(lbnd(1)-1+i,lbnd(2)-1+j)== 0) then
        BioEffects%TauEffect (i,j) = 1.0_fp
        BioEffects%ErodibilityEffect(i,j) = 1.0_fp
        spm_concentration(i,j,1:knum,1:nfrac)    = 0.0_fp
      endif
    enddo
  enddo

#ifdef DEBUG
  do j = 1, jnum
    do i = 1, inum
      if (mask(lbnd(1)-1+i,lbnd(2)-1+j)== 0) then
        write (0,*) 'in erosed component run:MPB and Mbalthica BioEffects%ErodibilityEffect=', &
          BioEffects%ErodibilityEffect(i,j)
        write (0,*) 'in erosed component run:MPB and Mbalthica BioEffects%TauEffect=', &
          BioEffects%TauEffect(i,j)
      end if
    enddo
  enddo
#endif

  call getfrac_dummy (anymud,sedtyp,nfrac,nmlb,nmub,frac,mudfrac)

  !> @todo why not take the one from sedparams.txt?
  sedd90 = 1.50_fp *sedd50 ! according to manual of Delft3d page 356

  call erosed(  nmlb   , nmub   , flufflyr , mfluff , frac , mudfrac , ws_convention_factor*ws, &
              & umod   , h1     , chezy    , taub   , nfrac, rhosol  , sedd50                 , &
              & sedd90 , sedtyp , sink     , sinkf  , sour , sourf   , anymud      , wave ,  uorb, &
              & tper   , teta   , spm_concentration , BioEffects     , nybot       , sigma_midlayer, &
              & u_bot  , v_bot  , u2d      , v2d    , h0   , mask    , advancecount, taubn, eq_conc, &
              & relative_layer_thickness, kmaxsd, taubmax )


  call MOSSCO_Reallocate(fieldList, 0, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (associated(includeList)) deallocate(includeList)
  allocate(includeList(1))
  includeList(1) = 'concentration_of_SPM_upward_flux_at_soil_surface'

  call MOSSCO_StateGet(exportState, fieldList, fieldCount=fieldCount, &
    include=includeList, &
    fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/),  rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  deallocate(includeList)

  if (fieldCount /= nfrac) then
    write(message,'(A)') trim(name)//' fatal error in mismatching field counts'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    localrc = ESMF_RC_ARG_BAD
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif

  do l=1, nfrac

    call ESMF_AttributeGet(fieldList(l), 'external_index', external_index, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    !write(0,*) external_index, nfrac_by_external_idx(external_index), external_idx_by_nfrac(l)

    call ESMF_FieldGet(fieldList(l), &
      farrayPtr=size_classes_of_upward_flux_of_pim_at_bottom(l)%ptr, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  enddo

  call MOSSCO_Reallocate(fieldList, 0, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)


  n = 0
  do l = 1, nfrac
    do nm = nmlb, nmub
!                rn(l,nm) = r0(l,nm) ! explicit
!!                r1(l,nm) = r0(l,nm) + dt*(sour(l,nm) + sourf(l,nm))/h0(nm) - dt*(sink(l,nm) + sinkf(l,nm))*rn(l,nm)/h1(nm)

      i = 1 + mod((nm-1),inum)
      j = 1 + int((nm-1)/inum)

      if (sedtyp (l) == 2) then !cohesive sediment
        kmx=1
      else
        kmx = kmaxsd
      end if

      !> Changed by cl to avoid calculation on land (mask == 0) and at
      !> boundary (mask == 2), only calculate where (mask == 1)
      if ( mask(lbnd(1)-1+i,lbnd(2)-1+j) == 1 ) then

         deposition_rate  = real(sink(l,nm),fp)*real(spm_concentration(i,j,kmx,l),fp)/1000._fp
         !deposition_rate  = min(0.5*real(ws(l,nm),fp),real(sink(l,nm),fp))*real(spm_concentration(i,j,kmx,l),fp)/1000._fp
         entrainment_rate = sour(l,nm)

        if (bedmodel) then
          call update_sediment_mass (mass(l,nm), dt,deposition_rate,entrainment_rate, area(i,j))
        end if

        size_classes_of_upward_flux_of_pim_at_bottom(l)%ptr(i,j) = entrainment_rate *1000.0_fp - deposition_rate *1000._fp   ! spm_concentration is in [g m-3] and sour in [Kgm-3] (that is why the latter is multiplied by 1000.
      endif
    enddo
    !> @todo check units and calculation of sediment upward flux, rethink ssus to be taken from FABM directly, not calculated by
    !! vanrjin84. So far, we add bed source due to sinking velocity and add material to water using constant bed porosity and
    !! sediment density.

  enddo

  !> save current water level to the old water level for the next time step
  h0 = h1

  call ESMF_ClockGet(clock, stopTime=stopTime, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (stopTime>currTime) then
    call ESMF_ClockAdvance(clock, timeStep=stopTime-currTime, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
  endif

  ! Preparing for output
  call ESMF_StateGet(exportState, 'rms_orbital_velocity_at_soil_surface', itemType=itemType, &
    rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (itemType /= ESMF_STATEITEM_FIELD) then
    write(message, '(A)') trim(name)//' did not find field rms_orbital_velocity_at_soil_surface'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  endif

  call ESMF_StateGet(exportState, 'rms_orbital_velocity_at_soil_surface', &
    field=field, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_FieldGet(field, status=status, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (status /= ESMF_FIELDSTATUS_COMPLETE) then
    write(message, '(A)') trim(name)//' received incomplete field'
    call MOSSCO_FieldString(field, message, rc=localrc)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  endif

  call ESMF_FieldGet(field, farrayPtr=rms_orbital_velocity%ptr, &
    exclusiveLBound=exclusiveLBound, &
    exclusiveUBound=exclusiveUBound, totalLBound=totalLBound, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  !> @todo proper bounds checking with eLBound required here
  if (.not. (      all(lbound(rms_orbital_velocity%ptr) .eq. (/   1,   1/) ) &
                   .and. all(ubound(rms_orbital_velocity%ptr) .eq. (/inum,jnum/) ) ) ) then
    write(message, '(A)') trim(name)//' invalid field bounds in field'
    call MOSSCO_FieldString(field, message, rc=localrc)
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    call ESMF_Finalize(endflag=ESMF_END_ABORT)
  end if

  do j=1,jnum
    do i= 1, inum
      rms_orbital_velocity%ptr(i,j) = uorb(inum*(j -1)+i)
    end do
  end do

  !> Provide optional output of shear stress
  call MOSSCO_Reallocate(fieldList, 0, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call MOSSCO_StateGet(exportState, fieldList=fieldList, fieldCount=&
    fieldCount, itemSearch='shear_stress_cohesive_at_soil_surface', &
    fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/), rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (fieldCount > 0) then

    call ESMF_FieldGet(fieldList(1), &
      farrayPtr=bottom_shear_stress%ptr, &
      exclusiveLBound=exclusiveLBound, &
      exclusiveUBound=exclusiveUBound, totalLBound=totalLBound, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    !> @todo proper bounds checking with eLBound required here

    do j=1,jnum
      do i= 1, inum
        bottom_shear_stress%ptr(i,j) = taub(inum * (j-1) + i)
      end do
    end do
  endif

  call MOSSCO_Reallocate(fieldList, 0, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call MOSSCO_StateGet(exportState, fieldList=fieldList, fieldCount=&
    fieldCount, itemSearch='shear_stress_noncohesive_at_soil_surface', &
    fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/), rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (fieldCount > 0) then

    call ESMF_FieldGet(fieldList(1), &
      farrayPtr=bottom_shear_stress_noncohesive%ptr, &
      exclusiveLBound=exclusiveLBound, &
      exclusiveUBound=exclusiveUBound, totalLBound=totalLBound, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    do j=1,jnum
      do i= 1, inum
        bottom_shear_stress_noncohesive%ptr(i,j) = taubn(inum * (j-1) + i)
      end do
    end do
  endif

  call ESMF_StateGet(exportState, 'Equilibrium_SPM_concentration_at_soil_surface_noncohesive', &
    itemType=itemType, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (itemType /= ESMF_STATEITEM_FIELD) then
    write(message, '(A)') trim(name)//' did not find field Equilibrium_SPM_concentration_at_soil_surface_noncohesive'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  endif

  call ESMF_StateGet(exportState, 'Equilibrium_SPM_concentration_at_soil_surface_noncohesive', field=field, &
    rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_FieldGet(field, status=status, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (status /= ESMF_FIELDSTATUS_COMPLETE) then
    write(message, '(A)') trim(name)//' received incomplete field'
    call MOSSCO_FieldString(field, message, rc=localrc)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  endif

  call ESMF_FieldGet(field, farrayPtr=equilibrium_spm%ptr, exclusiveLBound=exclusiveLBound, &
    exclusiveUBound=exclusiveUBound, totalLBound=totalLBound, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  !> @todo proper bounds checking with eLBound required here

  do j=1,jnum
    do i= 1, inum
      equilibrium_spm%ptr(i,j) = eq_conc(inum*(j -1)+i)
    end do
  end do

!#ifdef DEBUG

  if (bedmodel) then
    call ESMF_StateGet(exportState,'sediment_mass_in_bed', itemType=itemType,rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (itemType /= ESMF_STATEITEM_FIELD) then
      write(message, '(A)') trim(name)//' did not find field sediment_mass_in_bed'
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
    endif

    call ESMF_StateGet(exportState, 'sediment_mass_in_bed', field=field,rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_FieldGet(field, status=status, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (status /= ESMF_FIELDSTATUS_COMPLETE) then
      write(message, '(A)') trim(name)//' received incomplete field'
      call MOSSCO_FieldString(field, message, rc=localrc)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
      call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
    endif

    call ESMF_FieldGet(field, farrayPtr=sediment_mass,exclusiveLBound=exclusiveLBound3, &
      exclusiveUBound=exclusiveUBound3, totalLBound=totalLBound3, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    do j=1,jnum
      do i= 1,inum
        sediment_mass(lbnd(1)-1+i,lbnd(2)-1+j,1:nfrac) = mass(1:nfrac,inum*(j-1)+i)
      end do
    end do

  end if ! bedmodel
!#endif

  call ESMF_StateGet(exportState,'depth_average_concentration_of_SPM_in_water', &
    itemType=itemType,rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (itemType /= ESMF_STATEITEM_FIELD) then
    write(message, '(A)') trim(name)//' did not find field depth_average_concentration_of_SPM_in_water'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  endif

  call ESMF_StateGet(exportState, 'depth_average_concentration_of_SPM_in_water', field=field,rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_FieldGet(field, status=status, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (status /= ESMF_FIELDSTATUS_COMPLETE) then
    write(message, '(A)') trim(name)//' received incomplete field'
    call MOSSCO_FieldString(field, message, rc=localrc)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  endif

  call ESMF_FieldGet(field, farrayPtr=depth_avg_spm_concentration, &
    exclusiveLBound=exclusiveLBound3, &
    exclusiveUBound=exclusiveUBound3, totalLBound=totalLBound3, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  depth_avg_spm_concentration = 0.0_fp
  do i = 1,ubnd(1)
    do j = 1, ubnd(2)
      do l = 1, nfrac
        do k = 1,ubnd(3)
           depth_avg_spm_concentration (i,j,l)= depth_avg_spm_concentration (i,j,l) &
             + spm_concentration (i,j,k,l) * layer_thickness (i,j,k)
        end do
      end do
    end do
  end do

  do i = 1, ubnd(1)
    do j= 1, ubnd(2)
      if (depth (i,j)==0.0_fp) then
        depth_avg_spm_concentration (i,j,:)= 0.0_fp
        cycle
      end if
      depth_avg_spm_concentration (i,j,:)= depth_avg_spm_concentration (i,j,:)/depth (i,j)
    end do
  end do

  call ESMF_StateGet(exportState, 'Sum_depth_average_concentration_of_SPM_in_water',itemType=itemType, &
    rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (itemType /= ESMF_STATEITEM_FIELD) then
    write(message, '(A)') trim(name)//' did not find field Sum_depth_average_concentration_of_SPM_in_water'
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  endif

  call ESMF_StateGet(exportState,'Sum_depth_average_concentration_of_SPM_in_water',field=field, &
    rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  call ESMF_FieldGet(field, status=status, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  if (status /= ESMF_FIELDSTATUS_COMPLETE) then
    write(message, '(A)') trim(name)//' received incomplete field'
    call MOSSCO_FieldString(field, message, rc=localrc)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
    call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  endif

  call ESMF_FieldGet(field, farrayPtr=sum_depth_avg_spm_concentration, &
    exclusiveLBound=exclusiveLBound, &
    exclusiveUBound=exclusiveUBound, totalLBound=totalLBound, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  sum_depth_avg_spm_concentration = sum(depth_avg_spm_concentration, dim=3)

  !> Examine the budget of SPM and bedmass

  ! if (bedmodel) then
  !   write(message,'(A,3(X,ES10.3))') trim(name)//' bed mass original  ',mass_in_bed(RANGE2D,:)
  !   call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
  !   write(message,'(A,3(X,ES10.3))') trim(name)//' bed mass now       ',sediment_mass(RANGE2D,:)
  !   call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
  !   write(message,'(A,3(X,ES10.3))') trim(name)//' bed mass difference',sediment_mass(RANGE2D,:) &
  !     - mass_in_bed(RANGE2D,:)
  !   call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
  !   write(message,'(A,3(X,ES10.3))') trim(name)//' bed mass up flux   ',  &
  !     (dt*size_classes_of_upward_flux_of_pim_at_bottom(i)%ptr(:,:)/1000.0, i=1,nfrac)
  !   call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
  ! endif

  if (allocated(mass_in_spm)) deallocate(mass_in_spm)
  if (allocated(mass_total)) deallocate(mass_total)
  if (allocated(mass_in_bed)) deallocate(mass_in_bed)

  call MOSSCO_CompExit(gridComp, localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

end subroutine Run

#undef  ESMF_METHOD
#define ESMF_METHOD "Finalize"
  subroutine Finalize(gridComp, importState, exportState, parentClock, rc)

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(ESMF_MAXSTR) :: name
    logical                :: isPresent
    type(ESMF_Time)        :: currTime
    type(ESMF_Clock)       :: clock
    type(ESMF_Config)      :: config
    integer                :: localrc, i

    rc = ESMF_SUCCESS

    call MOSSCO_CompEntry(gridComp, parentClock, name=name, currTime=currTime, &
      importState=importState, exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call MOSSCO_CompExit(gridComp, localrc)

    return
#ifdef DEBUG
    close (unit707)
#endif

    !> deallocate all globally defined allocatables
    if (allocated(cdryb)) deallocate (cdryb)

    if (allocated(rhosol)) deallocate (rhosol)
    if (allocated(sedd50)) deallocate (sedd50)
    if (allocated(sedd90)) deallocate (sedd90)
    !
    if (allocated(chezy)) deallocate (chezy)
    if (allocated(h0)) deallocate (h0)
    if (allocated(h1)) deallocate (h1)
    if (allocated(umod)) deallocate (umod)
    if (allocated(u_bot)) deallocate (u_bot)
    if (allocated(v_bot)) deallocate (v_bot)

    if (allocated(taub)) deallocate (taub)
    if (allocated(taubn)) deallocate (taubn)
    if (allocated(eq_conc)) deallocate (eq_conc)
    if (allocated(ws)) deallocate (ws)
    !
    if (allocated (mass) ) deallocate (mass)
!    deallocate (massfluff)
    if (allocated(sink)) deallocate (sink)
    if (allocated(sinkf))deallocate (sinkf)
    if (allocated(sour)) deallocate (sour)
    if (allocated(sourf)) deallocate (sourf)

    !The DEALLOCATE statement releases the space allocated for an allocatable
    ! array or a pointer target and nullifies the pointer.
    if (associated(mfluff)) deallocate (mfluff)
    if (associated(frac)) deallocate (frac)
    if (allocated(sedtyp)) deallocate (sedtyp)
    if (allocated(mudfrac)) deallocate (mudfrac)

    if (allocated(uorb)) deallocate (uorb)
    if (allocated(tper)) deallocate (tper)
    if (allocated(teta)) deallocate (teta)
    if (associated(BioEffects%TauEffect)) deallocate (BioEffects%TauEffect)
    if (associated(BioEffects%ErodibilityEffect)) deallocate (BioEffects%ErodibilityEffect)

    ! Nullify the pointers within fields

    if (allocated(size_classes_of_upward_flux_of_pim_at_bottom)) then
      do i = 1, nfrac
        if (associated (size_classes_of_upward_flux_of_pim_at_bottom(i)%ptr)) &
          nullify (size_classes_of_upward_flux_of_pim_at_bottom(i)%ptr)
      end do
      deallocate (size_classes_of_upward_flux_of_pim_at_bottom)
    end if
    if (associated(spm_concentration)) nullify (spm_concentration)
    if (associated(depth_avg_spm_concentration)) nullify (depth_avg_spm_concentration)
    if (associated(sum_depth_avg_spm_concentration)) nullify (sum_depth_avg_spm_concentration)
    if (associated(interface_height_above_soil_surface)) nullify (interface_height_above_soil_surface)
    if (associated(rms_orbital_velocity%ptr)) nullify (rms_orbital_velocity%ptr)
    if (associated(equilibrium_spm%ptr)) nullify (equilibrium_spm%ptr)
    if (associated(bottom_shear_stress%ptr)) nullify (bottom_shear_stress%ptr)
    if (associated(bottom_shear_stress_noncohesive%ptr)) nullify (bottom_shear_stress_noncohesive%ptr)
    if (associated(mask)) nullify(mask)
    if (associated(area)) nullify(area)

    if (associated(layer_thickness)) deallocate (layer_thickness)
    if (associated(relative_layer_thickness)) deallocate (relative_layer_thickness)
    if (associated(sigma_midlayer)) deallocate (sigma_midlayer)
    if (associated(sediment_mass)) nullify (sediment_mass)

    call ESMF_GridCompGet(gridComp, configIsPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (isPresent) then

      call ESMF_GridCompGet(gridComp, config=config, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_ConfigDestroy(config, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    end if

    call ESMF_GridCompGet(gridComp, importStateIsPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (isPresent) call ESMF_StateValidate(importState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    !call MOSSCO_DestroyOwn(importState, trim(name), rc=localrc)
    !_MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompGet(gridComp, exportStateIsPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (isPresent) call ESMF_StateValidate(exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    !call MOSSCO_DestroyOwn(exportState, trim(name), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call MOSSCO_CompExit(gridComp, localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine Finalize

#undef  ESMF_METHOD
#define ESMF_METHOD "d90_from_d50"
  function d90_from_d50(d50)
    real(ESMF_KIND_R8)            :: d90_from_d50
    real(ESMF_KIND_R8),intent(in) :: d50

    d90_from_d50 = 2.0_ESMF_KIND_R8 * d50

  end function d90_from_d50

  function CalcOrbitalVelocity (SigWaveHeight, WaveNumber, WavePeriod, WaterDepth)
   ! RMS orbital velocity (uorb) to be used later in bedbc1993 (van Rijn, 1993) according to Eq. 11.144 Delft manual
!  According to Delft3d Manual p. 366 (definition of notations) RMS orbital velocity is
! taken from wave module and is multiplied by aquare root of 2.0 to get the desired peak orbital velocity
! at the bed in bedbc1993 (vanRijn(1993)).
! routine within Delft3d.
! It should be noted that for cohesive sediment transport the orbital velocity is used for Soulsby (2004).
   implicit none
   real (ESMF_KIND_R8) :: CalcOrbitalVelocity, Hrms
   real (ESMF_KIND_R8) :: SigWaveHeight, WaveNumber, WavePeriod, WaterDepth
   real (ESMF_KIND_R8), parameter :: pi = 3.14159265358979323846_fp, g = 9.81
!   logical             :: wave
   real (ESMF_KIND_R8) :: gammax  ! ratio of wave height to the water depth
   real (ESMF_KIND_R8) :: omega, k0, k0h


     gammax = 0.2
     waterdepth = max(0.01_fp, waterdepth)
     WavePeriod = max(0.01_fp,WavePeriod )

     Hrms = SigWaveHeight/ sqrt (2.0_fp)
     Hrms = min (Hrms, gammax * WaterDepth)

     omega      = 2.0_fp*pi/WavePeriod
     k0         = omega*omega/g
     k0h        = k0*WaterDepth
     if (k0h>pi) then
         WaveNumber = k0
     elseif (k0h<0.005_fp) then
         WaveNumber = omega/sqrt(g*WaterDepth)
     else
         WaveNumber = wavenr(WaterDepth,WavePeriod,g)
     endif

     if (WaveNumber*WaterDepth<80.0_fp) then

         CalcOrbitalVelocity  = 0.5*Hrms*omega/sinh(WaveNumber*WaterDepth)
         CalcOrbitalVelocity = CalcOrbitalVelocity*sqrt(pi)/2.0

     else
         CalcOrbitalVelocity =0.0_fp
     endif

  end function  CalcOrbitalVelocity

function wavenr(h,t,ag)
!----- GPL ---------------------------------------------------------------------
!
!  Copyright (C)  Stichting Deltares, 2011-2013.
!
!  This program is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation version 3.
!
!  This program is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!
!  contact: delft3d.support@deltares.nl
!  Stichting Deltares
!  P.O. Box 177
!  2600 MH Delft, Thsubroutine wavenr(h         ,t         ,k         ,ag        )
!----- GPL ---------------------------------------------------------------------
!
!  Copyright (C)  Stichting Deltares, 2011-2013.
!
!  This program is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation version 3.
!
!  This program is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!
!  contact: delft3d.support@deltares.nl
!  Stichting Deltares
!  P.O. Box 177
!  2600 MH Delft, the Netherlands
!
!  All indications and logos of, and references to, "Delft3D" and "Deltares"
!  are registered trademarks of Stichting Deltares, and remain the property of
!  Stichting Deltares. All rights reserved.
!
!-------------------------------------------------------------------------------
!  $Id: wavenr.f90 2392 2013-03-28 14:27:50Z mourits $
!  $HeadURL: https://svn.oss.deltares.nl/repos/delft3d/tags/2514/engines_gpl/flow2d3d/packages/io/src/output/wavenr.f90 $
!!--description-----------------------------------------------------------------
!
!    Function: Approximation of the dispersion, original sub-
!              routine Disp10 (L, T, h, g)
! Method used: relation according to linear wave theory:
!
!  = k TANH k
!
! h k = 2 pi h / L and w = (2 pi / T) sqrt (h/g), and L as
! nown.
! ational function approximation is made of the form :
!
!     1 + a1 w^2 + a2 w^4 + a3 w^6 + a4 w^8 + a5 w^10 + a6 w^12
! w^2 ---------------------------------------------------------
!     1 + b1 w^2 + b2 w^4 + b3 w^6 + b4 w^8           + a6 w^10
!
! ing the exact values for L for:
!  0.4, 0.7, 1.0, 1.3, 1.6, 1.95, 2.35, 2.9, 3.8 and 6.5,
!  a relative error less than 1.7E-6 for all w.
!
!
!!--pseudo code and references--------------------------------------------------
! NONE
!!--declarations----------------------------------------------------------------
    use precision
    use mathconsts
    !
    implicit none
    !
!
! Local parameters
!
    real(fp)            :: wavenr
    real(hp), parameter :: a1 = 5.060219360721177D-01, a2 = 2.663457535068147D-01,&
                         & a3 = 1.108728659243231D-01, a4 = 4.197392043833136D-02,&
                         & a5 = 8.670877524768146D-03, a6 = 4.890806291366061D-03,&
                         & b1 = 1.727544632667079D-01, b2 = 1.191224998569728D-01,&
                         & b3 = 4.165097693766726D-02, b4 = 8.674993032204639D-03

! Global variables
!
    real(fp), intent(in)               :: h  !!  Waterheight

    real(fp), intent(in)               :: t  !!  Period
    real(fp), intent(in)               :: ag !!  Gravitational acceleration
!
!
! Local variables
!
    real(hp)               :: den                  ! Denominator
    real(hp)               :: kd                   ! Double value for K
    real(hp)               :: num                  ! Numerator
    real(hp)               :: ome2                 ! Omega
!
!
!! executable statements -------------------------------------------------------
!
    call init_mathconsts()
    ome2 = (2.0D0*pi_hp/real(t, hp))**2*real(h, hp)/real(ag, hp)
    !
    num = 1.0D0 +                                                               &
        & ome2*(a1 + ome2*(a2 + ome2*(a3 + ome2*(a4 + ome2*(a5 + ome2*a6)))))
    den = 1.0D0 + ome2*(b1 + ome2*(b2 + ome2*(b3 + ome2*(b4 + ome2*a6))))
    kd = sqrt(ome2*num/den)/real(h, hp)
    wavenr = real(kd, fp)
end function wavenr

#undef ESMF_METHOD
#define ESMF_METHOD "map_variable"
subroutine map_variable(state, varname, farray1, rc)

  type(ESMF_State), intent(in) :: state
  character(len=*), intent(in) :: varname
  real(ESMF_KIND_R8), allocatable :: farray1(:)
  integer(ESMF_KIND_I4), intent(out), optional :: rc

  integer(ESMF_KIND_I4)       :: localrc, i, j, lbnd(3), ubnd(3)
  integer(ESMF_KIND_I4)       :: fieldCount, rank, rc_
  type(ESMF_Grid)             :: grid
  type(ESMF_Mesh)             :: mesh
  type(ESMF_GeomType_Flag)    :: geomType
  type(ESMF_Field), allocatable :: fieldList(:)
  logical                     :: isPresent
  real(ESMF_KIND_R8), pointer :: farrayPtr2(:,:) => null()
  character(ESMF_MAXSTR)      :: message, owner_

  if (present(rc)) rc = ESMF_SUCCESS
  owner_ = '--'
  lbnd = 1
  ubnd = 1

  call MOSSCO_StateGet(state, itemSearch=trim(varname), fieldCount= &
    fieldCount, fieldSTatusList=(/ESMF_FIELDSTATUS_COMPLETE/), fieldList &
    =fieldList, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if (fieldCount < 1) return

  call ESMF_FieldGet(fieldList(1), rank=rank, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_FieldGetBounds(fieldList(1), exclusiveLBound=lbnd(1:rank), &
     exclusiveUBound=ubnd(1:rank), rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  !> @todo inum, jnum are still global
  inum=ubnd(1)-lbnd(1)+1
  jnum=ubnd(2)-lbnd(2)+1

  if (.not.allocated(farray1)) allocate(farray1(inum*jnum))

  if (inum*jnum /= size(farray1)) then
    write(message, '(A)') trim(owner_)//' obtained invalid data for '
    call MOSSCO_FieldString(fieldList(1), message)
    rc = ESMF_RC_ARG_BAD
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
  endif

  call ESMF_FieldGet(fieldList(1), geomType=geomType, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if (geomType == ESMF_GEOMTYPE_MESH) then
    localrc = ESMF_RC_NOT_IMPL
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  elseif (geomType == ESMF_GEOMTYPE_GRID) then
    call ESMF_FieldGet(fieldList(1), grid=grid, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call ESMF_GridGetItem(grid, ESMF_GRIDITEM_MASK, isPresent=isPresent, &
      rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    !> @todo mask is still a global variable
    if (isPresent) then
      call ESMF_GridGetItem(grid, ESMF_GRIDITEM_MASK, farrayPtr=mask, &
        rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    else
      if (.not.associated(mask)) allocate(mask(RANGE2D))
      mask = 1
    endif
  else
    localrc = ESMF_RC_NOT_IMPL
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
  endif

  if (rank == 2) then
    call ESMF_FieldGet(fieldList(1), farrayPtr=farrayPtr2, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    !> @todo what about the mask?
    do j=1, jnum
      do i=1, inum
        farray1(inum * (j - 1) + i) = farrayPtr2(lbnd(1)+i-1, lbnd(2)+j-1)
      enddo
    enddo

  else
    localrc = ESMF_RC_NOT_IMPL
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
  endif

  nullify(farrayPtr2)

  call MOSSCO_Reallocate(fieldList, 0, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

end subroutine map_variable

end module erosed_component
