!> @brief FABM sediment ESMF component
!
!> The ESMF/FABM sediment driver component module provides infrastructure for the
!! MOSSCO sediment component.
!
!  This computer program is part of MOSSCO.
!> @copyright Copyright (C) 2021-2022 Helmholtz-Zentrum Hereon
!> @copyright Copyright (C) 2013-2021 Helmholtz-Zentrum Geesthacht
!> @author Carsten Lemmen <carsten.lemmen@hereon.de>
!> @author Richard Hofmeister
!
! MOSSCO is free software: you can redistribute it and/or modify it under the
! terms of the GNU General Public License v3+.  MOSSCO is distributed in the
! hope that it will be useful, but WITHOUT ANY WARRANTY.  Consult the file
! LICENSE.GPL or www.gnu.org/licenses/gpl-3.0.txt for the full license terms.
!
#define _GRID_ sed%grid
#define _INUM_ _GRID_%inum
#define _JNUM_ _GRID_%jnum
#define _KNUM_ _GRID_%knum
#define _IRANGE_ 1:_INUM_
#define _JRANGE_ 1:_JNUM_
#define _KRANGE_ 1:_KNUM_

#define _RK4_ 1
#define _ADAPTIVE_EULER_ 2

! #define DEBUG_NAN

#define RANGE1D lbnd(1):ubnd(1)
#define RANGE2D RANGE1D,lbnd(2):ubnd(2)
#define RANGE3D RANGE2D,1:sed%knum

#define ESMF_CONTEXT  line=__LINE__,file=ESMF_FILENAME,method=ESMF_METHOD
#define ESMF_ERR_PASSTHRU msg="MOSSCO subroutine call returned error"
#undef ESMF_FILENAME
#define ESMF_FILENAME "fabm_sediment_component.F90"

#define _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(X) if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=X)) call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)

#define _MOSSCO_LOG_ERROR if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT)) continue

module fabm_sediment_component

  use esmf
  use fabm_sediment_driver
  use solver_library!, only : ode_solver
  use mossco_strings
  use mossco_state
  use mossco_field
  use mossco_component
  use mossco_grid
  use mossco_config

  implicit none

  private

  real(rk)  :: dzmin,dt,dt_spinup
  real(rk)  :: dt_min=1.0e-8_rk,relative_change_min=-0.9_rk
  integer   :: tnum,funit,output=-1,k,n,numyears,numlayers
  integer   :: ode_method=_ADAPTIVE_EULER_
  integer   :: presimulation_years=-1
  integer   :: bcup_dissolved_variables=2
  real(rk)  :: pel_NO3=5.0_rk, pel_NH4=5.0_rk, pel_PO4=0.5_rk, pel_O2=250_rk
  real(rk)  :: pflux_lDetC=10.0_rk, pflux_sDetC=10.0_rk, pflux_lDetN=1.5_rk
  real(rk)  :: pflux_sDetN=1.5_rk, pflux_lDetP=0.2_rk, pel_Temp=5.0_rk
  !> deprecated variables (to enable outdated namelists)
  real(rk)  :: pflux_sDet=10.0_rk, pflux_fDet=10.0_rk, pflux_detP=0.2_rk

  real(rk),dimension(:,:,:,:),allocatable,target :: conc
  real(rk),dimension(:,:,:),pointer              :: diag
  real(rk),dimension(:,:,:),allocatable,target   :: bdys,fluxes
  real(rk),dimension(:,:),pointer   :: fptr2d
  real(rk),dimension(:), pointer    :: farrayPtr1
  real(rk),dimension(:), pointer    :: farrayPtr1_vs
  real(rk),dimension(:,:), pointer  :: statemesh_ptr
  character(len=ESMF_MAXSTR) :: ugrid_name=''

  type(type_sed),save :: sed
  type(type_sed),save :: sed1d

  namelist /run_nml/ numyears, dt, output, numlayers, dzmin,                          &
                     ode_method, dt_min, relative_change_min,                         &
                     ugrid_name, bcup_dissolved_variables, presimulation_years,       &
                     pel_Temp, pel_NO3, pel_NH4, pel_PO4, pel_O2,                     &
                     pflux_lDetC, pflux_sDetC, pflux_lDetN, pflux_sDetN, pflux_lDetP, &
                     pflux_sDet, pflux_fDet, pflux_detP

  public SetServices

  contains

  !> Provide an ESMF compliant SetServices routine, which defines
  !! the entry points for Init/Run/Finalize

#undef  ESMF_METHOD
#define ESMF_METHOD "SetServices"
  subroutine SetServices(gridcomp, rc)

    type(ESMF_GridComp)                :: gridcomp
    integer(ESMF_KIND_I4), intent(out) :: rc

    integer(ESMF_KIND_I4)              :: localrc

    rc = ESMF_SUCCESS

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_INITIALIZE, phase=0, &
      userRoutine=InitializeP0, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_INITIALIZE, phase=1, &
      userRoutine=InitializeP1, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_INITIALIZE, phase=2, &
      userRoutine=InitializeP2, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_READRESTART, phase=1, &
      userRoutine=ReadRestart, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_RUN, Run, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_FINALIZE, Finalize, &
      rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine SetServices

#undef  ESMF_METHOD
#define ESMF_METHOD "InitializeP0"
  subroutine InitializeP0(gridComp, importState, exportState, parentClock, rc)

    implicit none

    type(ESMF_GridComp)   :: gridComp
    type(ESMF_State)      :: importState
    type(ESMF_State)      :: exportState
    type(ESMF_Clock)      :: parentClock
    integer, intent(out)  :: rc

    character(len=10)           :: InitializePhaseMap(2)
    character(len=ESMF_MAXSTR)  :: name
    type(ESMF_Time)             :: currTime
    integer                     :: localrc

    rc=ESMF_SUCCESS

    call MOSSCO_CompEntry(gridComp, parentClock, name=name, currTime=currTime, &
      importState=importState, exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    InitializePhaseMap(1:2) = (/'IPDv00p1=1','IPDv00p2=2'/)

    call ESMF_AttributeAdd(gridComp, convention="NUOPC", purpose="General", &
      attrList=(/"InitializePhaseMap"/), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_AttributeSet(gridComp, name="InitializePhaseMap", valueList=InitializePhaseMap, &
      convention="NUOPC", purpose="General", rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call MOSSCO_CompExit(gridComp, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine InitializeP0

  !> Initialize the component
  !!
  !! Allocate memory for boundaries and fluxes, create ESMF fields
  !! and export them
#undef  ESMF_METHOD
#define ESMF_METHOD "InitializeP1"
  subroutine InitializeP1(gridComp, importState, exportState, parentClock, rc)
    use fabm_types, only: output_none
    implicit none

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    type(ESMF_TimeInterval)    :: timeInterval,alarmInterval
    character(len=ESMF_MAXSTR) :: string,fileName,varname
    type(ESMF_Config)          :: config
    type(ESMF_Field)     :: field
    type(ESMF_Array)     :: array
    integer              :: n,i,j,k
    type(ESMF_DistGrid)  :: distGrid_3d,distGrid_2d
    type(ESMF_Grid)      :: state_grid,flux_grid, grid
    type(ESMF_Mesh)      :: surface_mesh, state_mesh
    type(ESMF_ArraySpec) :: flux_array,state_array
    type(ESMF_Index_Flag):: indexflag

    real(ESMF_KIND_R8),dimension(:),pointer       :: farrayPtr1
    real(ESMF_KIND_R8),dimension(:,:),pointer     :: farrayPtr2
    real(ESMF_KIND_R8),dimension(:,:,:),pointer   :: farrayPtr3
    real(ESMF_KIND_R8),dimension(:,:,:,:),pointer :: farrayPtr4
    real(ESMF_KIND_R8),dimension(:,:,:,:),pointer :: rhs
    integer(ESMF_KIND_I4) :: fieldcount
    integer(ESMF_KIND_I8) :: tidx
    type(ESMF_Alarm)      :: outputAlarm

    character(len=ESMF_MAXSTR) :: timestring, name, message, units
    integer(ESMF_KIND_I4)      :: localPet, petCount, itemCount
    type(ESMF_Clock)           :: clock
    type(ESMF_Time)            :: currTime, startTime, stopTime
    integer(ESMF_KIND_I8)      :: seconds, advanceCount
    type(ESMF_TimeInterval)    :: timeStep
    logical                    :: clockIsPresent, isPresent
    integer                    :: numElements,numNodes, exclusiveCount(2), rank
    character(len=ESMF_MAXSTR) :: foreignGeomFieldName
    integer(ESMF_KIND_I4)      :: localrc, spatialDim
    integer, dimension(:,:), pointer :: gridmask=>null()
    type(ESMF_StateItem_Flag)  :: itemType
    type(ESMF_GeomType_Flag)   :: geomType
    type(ESMF_CoordSys_Flag)   :: coordSys

    type(ESMF_MeshLoc)                 :: meshloc
    integer(ESMF_KIND_I4)              :: lbnd(3), ubnd(3)
    character(len=ESMF_MAXSTR)         :: creatorName
    type(ESMF_Field), allocatable      :: fieldList(:)
    integer                            :: unit
    type(ESMF_VM)                      :: vm

    call MOSSCO_CompEntry(gridComp, parentClock, name=name, currTime=currTime, &
      importState=importState, exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_GridCompGet(gridComp, vm=vm, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    lbnd(:)=1
    ubnd(:)=1

    !! read namelist input for control of timestepping
    !> @todo this could also come from the .cfg
    call ESMF_UtilIOUnitGet(unit, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    open(unit,file='run_sed.nml',action='read',status='old')
    read(unit,nml=run_nml)

    !> Convert from deprecated namelist items detP, fDet, sDet
    if (pflux_sDet /= pflux_sDetC) pflux_sDetC = pflux_sDet
    if (pflux_fDet /= pflux_lDetC) pflux_lDetC = pflux_fDet
    if (pflux_detP /= pflux_lDetP) pflux_lDetP = pflux_detP

    !! Set the time step end stop time
    call ESMF_GridCompGet(gridComp, clock=clock, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_TimeIntervalSet(timeInterval, s_r8=dt, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_ClockSet(clock, timeStep=timeInterval, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    !! also from namelist, the output timestep is read and
    !! used to create an alarm
    !! no output, if output <= 0
    sed%do_output = output .gt. 0

#if 0
    if (sed%do_output) then
      call ESMF_TimeIntervalSet(alarmInterval,s_i8=int(dt*output,kind=ESMF_KIND_I8),rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      outputAlarm = ESMF_AlarmCreate(clock,ringTime=startTime+alarmInterval, &
        name='output', ringInterval=alarmInterval,rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(outputAlarm,'creator', trim(name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    endif
#endif

    !! read ugrid mesh to get number of sediment columns
    sed%grid%use_ugrid = ugrid_name /= ''
    if (sed%grid%use_ugrid) sed%grid%type=UGRID
    !> todo: check importState for foreign_grid_field_name

    if (sed%grid%type==UGRID) then
      surface_mesh = ESMF_MeshCreate(filename=ugrid_name, &
          fileformat=ESMF_FILEFORMAT_UGRID, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_MeshGet(surface_mesh,numOwnedElements=numElements, &
        numOwnedNodes=numNodes)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      ubnd(1)=numElements
      sed%grid%inum=numElements
      sed%grid%jnum=1
    else
      call ESMF_AttributeGet(importState, name='foreign_grid_field_name', &
           value=foreignGeomFieldName, defaultValue='none',rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (trim(foreignGeomFieldName)=='none') then
        sed%grid%type=LOCAL_GRID
      else
        sed%grid%type=FOREIGN_GRID
      endif
    endif

    if (sed%grid%type==FOREIGN_GRID) then

      call MOSSCO_StateGet(importState, fieldList, fieldCount=fieldCount, &
        itemSearch=foreignGeomFieldName, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (fieldCount < 1) then
        call MOSSCO_StateLog(importState, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        write(message,'(A)') trim(name)//' cannot find specified foreign grid field '//trim(foreignGeomFieldName)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
        rc = ESMF_RC_NOT_FOUND
        return
      endif

      call ESMF_StateGet(importState, trim(foreignGeomFieldName), &
        itemType=itemType, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_StateGet(importState, foreignGeomFieldName, field, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      write(message,'(A)') trim(name)//' uses foreign geometry from '
      call MOSSCO_FieldString(fieldList(1), message, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

      call ESMF_FieldGet(fieldList(1), geomType=geomType, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (geomType /= ESMF_GEOMTYPE_GRID .and. geomType /= ESMF_GEOMTYPE_MESH) then
        write(message,'(A)') trim(name)//' cannot use geometries other than grid or mesh'
        rc = ESMF_RC_NOT_IMPL
        return
      endif

      if (geomType == ESMF_GEOMTYPE_GRID) then
        call ESMF_FieldGet(fieldList(1), grid=grid, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_GridGet(grid, rank=rank, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (rank == 3) then
          flux_grid = MOSSCO_GridCreateFromOtherGrid(grid, rc=localrc)
          call ESMF_GridGet(grid, staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER, &
            localDe=0, exclusiveUbound=ubnd, exclusiveLbound=lbnd, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          if (numlayers /= ubnd(rank)-lbnd(rank) + 1) then
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
            numlayers = ubnd(rank)-lbnd(rank) + 1
            write(message,'(A,I3)') trim(name)//' overwrites namelist with 3D-grid numlayers = ',numlayers
            call ESMF_LogWrite(trim(message),ESMF_LOGMSG_WARNING)
          endif
        else
          flux_grid = grid
        endif

        call ESMF_GridGet(flux_grid, rank=rank, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (rank/=2) then
          write(message,'(A)') trim(name)//' could not create rank 2 grid'
          call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
          call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=localrc)
        endif

        call ESMF_GridGet(flux_grid, staggerloc=ESMF_STAGGERLOC_CENTER, localDe=0, &
          exclusiveLBound=lbnd(1:2), exclusiveUBound=ubnd(1:2), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        sed%grid%inum=ubnd(1)-lbnd(1)+1
        sed%grid%jnum=ubnd(2)-lbnd(2)+1

      elseif (geomType == ESMF_GEOMTYPE_MESH) then

        call ESMF_FieldGet(fieldList(1), mesh=surface_mesh, rank=rank, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_MeshGet(surface_mesh, spatialDim=spatialDim, coordSys=coordSys, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (spatialDim /= 2) then
          write(message,'(A)') trim(name)//' cannot use spatial dimension other than 2'
          rc = ESMF_RC_NOT_IMPL
          return
        endif

        if (coordSys /= ESMF_COORDSYS_SPH_DEG .and. coordSys /= ESMF_COORDSYS_SPH_RAD) then
          write(message,'(A)') trim(name)//' cannot use non-spherical coordinate system'
          rc = ESMF_RC_NOT_IMPL
          return
        endif

        call ESMF_MeshGet(surface_mesh, numOwnedElements=numElements, &
          numOwnedNodes=numNodes, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        !> For SCHISM, we need the computational bounds for the fields if they
        !> are on elements
        call ESMF_FieldGet(fieldList(1), meshloc=meshloc, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_AttributeGet(fieldList(1), 'creator', value=creatorName, &
          defaultValue='unknown', rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (trim(creatorName) == 'schism') then
          call ESMF_FieldGetBounds(fieldList(1), localDe=0, computationalLBound=lbnd(1:1), &
            computationalUBound=ubnd(1:1), rc=localrc)
        else
          call ESMF_FieldGetBounds(fieldList(1), localDe=0, exclusiveLBound=lbnd(1:1), &
            exclusiveUBound=ubnd(1:1), rc=localrc)
        endif
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        sed%grid%use_ugrid=.true.
        sed%grid%inum=ubnd(1)-lbnd(1)+1
        sed%grid%jnum=1

        ! Correct lbnd for rank 1
        !> @todo why is this necessary?
        if (rank==1) then
          i=lbnd(1)
          lbnd(1)=i
          ubnd(1)=i + sed%grid%inum - 1
        endif

        write(message,*) trim(name)//' uses unstructured grid, number of elements:', numElements
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

      endif ! grid or mesh

    elseif (sed%grid%type==LOCAL_GRID) then
      write(message,'(A)') trim(name)//' uses local 1x1 horizontal grid'
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
      sed%grid%inum=1
      sed%grid%jnum=1
    endif

    !! The grid specification should also go to outside this routine, and update the grid of
    !! this component, numlayers and dzmin are read from nml
    sed%grid%knum=numlayers
    sed%grid%dzmin=dzmin

    sed1d%grid%inum=1
    sed1d%grid%jnum=1
    sed1d%grid%knum=numlayers
    sed1d%grid%dzmin=dzmin

    !! Write log entries
    !> @todo consider mesh/intformat, write out GridPrint here
    write(message,'(A,I5,A,I5,A,I5)') trim(name)//' initializes fields (i x j x k)', &
      _INUM_,' x ',_JNUM_,' x ',_KNUM_
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    !! get grid mask
    !allocate(sed%mask(1:sed%grid%inum,1:sed%grid%jnum,1:sed%grid%knum))
    allocate(sed%mask(RANGE2D,1:sed%grid%knum))
    sed%mask = .false.
    isPresent = .true.

    if (sed%grid%type==FOREIGN_GRID .and. geomType==ESMF_GEOMTYPE_GRID) then
      call ESMF_GridGetItem(flux_grid, ESMF_GRIDITEM_MASK, isPresent=isPresent, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    endif

    if (sed%grid%type==FOREIGN_GRID .and. isPresent &
      .and. geomType==ESMF_GEOMTYPE_GRID) then

      call ESMF_GridGetItem(flux_grid, ESMF_GRIDITEM_MASK, &
        farrayPtr=gridmask, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_GridGetItemBounds(flux_grid, ESMF_GRIDITEM_MASK, &
        exclusiveUBound=ubnd, exclusiveLBound=lbnd, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      do i=lbnd(1),ubnd(1)
        do j=lbnd(2),ubnd(2)
          sed%mask(i,j,:) = (gridmask(i,j).le.0)
        enddo
      enddo
    endif

    if (.not.isPresent .or. localrc /= ESMF_SUCCESS) then
      write(message,'(A)') trim(name)//' found no mask in foreign grid, compute every sediment column'
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
    endif

    write(message,'(A)') trim(name)//' initializes grid'
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    call sed%grid%init_grid()

    write(message,'(A)') trim(name)//' initializes itself'
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    call sed%initialize(unit)
    close(unit)

    !! Allocate all arrays conc, bdys, fluxes
    allocate(conc(RANGE3D,sed%nvar))
    ! link conc to fabm_sediment_driver
    sed%conc => conc
    ! check for valid grid and porosity

    write(message,'(A)') trim(name)//' checks domain'
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    call sed%check_domain()
    ! initialise values
    conc = 0.0_rk

    write(message,'(A)') trim(name)//' initializes concentrations'
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    call sed%init_concentrations()
    !> Allocate boundary conditions and initialize with zero
    allocate(bdys(RANGE2D,sed%nvar+1))
    bdys(RANGE2D,:) = 0.0_rk
    allocate(fluxes(RANGE2D,sed%nvar))
    fluxes(RANGE2D,:) = 0.0_rk

    call set_boundary_flags(sed,importState)
    !> create list of state variables for export
    call sed%get_all_export_states()

    !> run for some years into quasi-steady-state
    call ESMF_UtilIOUnitGet(unit, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    open(unit,file='run_sed.nml',action='read',status='old')

    !> Convert from deprecated namelist items detP, fDet, sDet
    if (pflux_sDet /= pflux_sDetC) pflux_sDetC = pflux_sDet
    if (pflux_fDet /= pflux_lDetC) pflux_lDetC = pflux_fDet
    if (pflux_detP /= pflux_lDetP) pflux_lDetP = pflux_detP

    call sed1d%grid%init_grid()
    call sed1d%initialize(unit)
    close(unit)

    allocate(sed1d%conc(1,1,_KNUM_,1:sed%nvar))
    !> check for valid grid and porosity
    call sed1d%check_domain()
    call sed1d%init_concentrations()
    if (presimulation_years.gt.0) then
      write(0,*) '  postinit run sediment model on initial profiles for ',presimulation_years,' years'
      write(message,'(A,I3,A)') trim(name)//' runs ', presimulation_years, ' spinup years'
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
    endif

    dt_spinup=3600.0_rk
    sed%bdys   => bdys
    sed%fluxes => fluxes

    ! set solver_settings:
    sed%dt_min=dt_min
    sed%relative_change_min=relative_change_min
    sed1d%dt_min=dt_min
    sed1d%relative_change_min=relative_change_min
    if (_INUM_ > 0 .and. _JNUM_ > 0) then
      !sed1d%bdys   => bdys(RANGE2D,:)
      !sed1d%fluxes => fluxes(RANGE2D,:)
      sed1d%bdys   => bdys(1:1,1:1,:)
      sed1d%fluxes => fluxes(1:1,1:1,:)
    endif

    ! set boundary conditions for pre-simulation
    bdys(RANGE2D,1) = pel_Temp !degC
    do n=1,size(sed%model%state_variables)
      varname = trim(only_var_name(sed%model%state_variables(n)%long_name))
      if (trim(varname) == 'dissolved_nitrate')            bdys(:,:,n+1)=pel_NO3
      if (trim(varname) == 'dissolved_ammonium')           bdys(:,:,n+1)=pel_NH4
      if (trim(varname) == 'dissolved_phosphate')          bdys(:,:,n+1)=pel_PO4
      if (trim(varname) == 'dissolved_oxygen')             bdys(:,:,n+1)=pel_O2
      if (trim(varname) == 'dissolved_reduced_substances') bdys(:,:,n+1)=pel_O2 !0.0_rk
      if (trim(varname) == 'detritus_labile_carbon')       fluxes(RANGE2D,n)=pflux_lDetC/86400.0_rk
      if (trim(varname) == 'detritus_semilabile_carbon')   fluxes(RANGE2D,n)=pflux_sDetC/86400.0_rk
      if (trim(varname) == 'detritus_labile_nitrogen')     fluxes(RANGE2D,n)=pflux_lDetN/86400.0_rk
      if (trim(varname) == 'detritus_semilabile_nitrogen') fluxes(RANGE2D,n)=pflux_sDetN/86400.0_rk
      if (trim(varname) == 'detritus_labile_phosphorus')   fluxes(RANGE2D,n)=pflux_lDetP/86400.0_rk
      !> For legacy reasons, these are the old names in omexdia
      if (trim(varname) == 'fast_detritus_C')              fluxes(RANGE2D,n)=pflux_lDetC/86400.0_rk
      if (trim(varname) == 'slow_detritus_C')              fluxes(RANGE2D,n)=pflux_sDetC/86400.0_rk
      if (trim(varname) == 'detritus-P')                   fluxes(RANGE2D,n)=pflux_lDetP/86400.0_rk
      if (trim(varname) == 'detritus_phosphorus')          fluxes(RANGE2D,n)=pflux_lDetP/86400.0_rk
    enddo

    ! use Dirichlet boundary condition for pre-simulation
    sed%bcup_dissolved_variables = 2
    sed1d%bcup_dissolved_variables = 2
    sed1d%adaptive_solver_diagnostics = .true.
    sed1d%bioturbation_profile=0

    if (presimulation_years .gt. 0) then

      do tidx=1,int(presimulation_years*365*24/(dt_spinup/3600.0_rk),kind=ESMF_KIND_I8)
        call ode_solver(sed1d,dt_spinup,ode_method)
      enddo

      !> @todo this does not make sense as it is a single column!
      if (ode_method == 2) then
        write (message,*) trim(name)//' found minimum dt:',sed1d%last_min_dt,' at cell ',sed1d%last_min_dt_grid_cell
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      endif

    endif

    do i=lbnd(1),ubnd(1)
      do j=lbnd(2),ubnd(2)
        if (.not.sed%mask(i,j,1)) sed%conc(i,j,:,:) = sed1d%conc(1,1,:,:)
      enddo
    enddo

    write(message,'(A)') trim(name)//' applied 1D profile to 3D concentrations'
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    !> call the model equations in order to fill the diagnostic variables
    allocate(rhs(sed%inum,sed%jnum,sed%knum,sed%nvar), stat=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(localrc)

    write(message,'(4(A,I4))') trim(name)//' allocated right-hand sides as ', &
      sed%inum,' x ',sed%jnum,' x ',sed%knum,' x ', sed%nvar
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    call sed%get_rhs(rhs)
    
    call ESMF_VMBarrier(vm, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(message,'(A)') trim(name)//' calulated right-hand sides'
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    !> @todo for mysterious reasons, the pointer cannot be deallocated, 
    ! throws a segfault mem not mapped
    ! thus for now just nullified (with small mem leaking)
    !if (associated(rhs)) deallocate(rhs, stat=localrc)
    !_MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(localrc)
    if (associated(rhs)) nullify(rhs)

    call ESMF_VMBarrier(vm, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    write(message,'(A)') trim(name)//' calculated initial diagnostics'
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    !> it is possible to use flux-boundary condition for dissolved variables
    !> as calculated in get_boundary_conditions after presimulation,
    !> Dirichlet boundary conditions are numerically more stable.
    sed%bcup_dissolved_variables = bcup_dissolved_variables

    !! define an output unit for tsv output
    !> @todo restrict to first PET only
    if (sed%do_output) then
      call ESMF_UtilIOUnitGet(funit, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      
      open(funit,file='output.dat')
      write(funit,fmt='(A,A,A,A)',advance='no') 'time(s) ','depth(m) ','layer-height(m) ','porosity() '
      do n=1,sed%nvar
        write(funit,fmt='(A,A)',advance='no') ' ',trim(sed%model%state_variables(n)%name)
      enddo
      do n=1,size(sed%model%diagnostic_variables)
        write(funit,fmt='(A,A)',advance='no') ' ',trim(sed%model%diagnostic_variables(n)%name)
      enddo
      write(funit,*)

      write(message,'(A)') trim(name)//' wrote header for "output.dat"'
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
  
    endif

    if (sed%grid%use_ugrid) then
      !! create state mesh
#if 0
      state_mesh = ESMF_MeshCreate(surface_mesh,rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      !call ESMF_AttributeSet(surface_mesh,'creator', trim(name), rc=localrc)
#endif

      !! create state and flux fields
      do n=1,size(sed%export_states)
        field = ESMF_FieldCreate(surface_mesh, &
                  name=trim(sed%export_states(n)%standard_name)//'_in_soil', &
                  typekind=ESMF_TYPEKIND_R8, meshloc=ESMF_MESHLOC_ELEMENT, &
                  ungriddedLBound=(/1/), ungriddedUBound=(/sed%grid%knum/), &
                  rc=localrc)
                  !gridToFieldMap=(/1,2/), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_FieldGet(field=field, farrayPtr=statemesh_ptr, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        do k=1,sed%grid%knum
          statemesh_ptr(RANGE1D,k) = sed%export_states(n)%data(RANGE1D,1,k)
        enddo

        write(message, '(A)') trim(name)//' created for export bulk '
        call MOSSCO_FieldString(field, message, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

        call ESMF_StateAddReplace(exportState,(/field/),rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (sed%export_states(n)%fabm_id/=-1) then
          !> add boundary upward fluxes
          field = ESMF_FieldCreate(surface_mesh, &
                    name=trim(sed%export_states(n)%standard_name)//'_upward_flux_at_soil_surface', &
                    typekind=ESMF_TYPEKIND_R8, &
                    meshloc=ESMF_MESHLOC_ELEMENT,rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_FieldGet(field=field, farrayPtr=farrayPtr1, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          farrayPtr1 = -fluxes(RANGE1D,lbnd(1),sed%export_states(n)%fabm_id)

          write(message, '(A)') trim(name)//' created for export '
          call MOSSCO_FieldString(field, message, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

          call ESMF_StateAddReplace(exportState,(/field/),rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        endif
      enddo
#if 0
      do n=1,size(sed%model%diagnostic_variables)
        if (sed%model%diagnostic_variables(n)%output /= output_none) then
          diag => sed%diagnostic_variables(n)
          statemesh_ptr => diag(RANGE1D,lbnd(1),:)
          field = ESMF_FieldCreate(state_mesh,farrayPtr=statemesh_ptr, &
                   name=only_var_name(sed%model%diagnostic_variables(n)%long_name)//'_in_soil', rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          write(message, '(A)') trim(name)//' created for export '
          call MOSSCO_FieldString(field, message, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

          call ESMF_StateAddReplace(exportState,(/field/),rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        endif
      enddo
#endif

      !! create boundary fields in import State
      !> @todo should we advertise the geometry here?
      !> it is also fine to obtain a default value without geometry
      field = ESMF_FieldEmptyCreate(name='porosity_at_soil_surface', rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      write(message, '(A)') trim(name)//' created for export '
      call MOSSCO_FieldString(field, message, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

      call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      !> @todo should we advertise the geometry here?
      !> it is also fine to obtain a default value without geometry
      field = ESMF_FieldCreate(surface_mesh, name='temperature_at_soil_surface', &
        typekind=ESMF_TYPEKIND_R8, meshloc=ESMF_MESHLOC_ELEMENT, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_FieldGet(field,farrayPtr=farrayPtr1,rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      farrayPtr1(RANGE1D)=bdys(RANGE1D,lbnd(2),1)

      write(message, '(A)') trim(name)//' created for import '
      call MOSSCO_FieldString(field, message, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

      call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      !> Allow upper boundary for all bulk state variables to be imported
      do n=1,size(sed%export_states)
        if (sed%export_states(n)%fabm_id/=-1) then
          field = ESMF_FieldCreate(surface_mesh, &
                   name=trim(sed%export_states(n)%standard_name)//'_at_soil_surface', &
                   typekind=ESMF_TYPEKIND_R8, meshloc=ESMF_MESHLOC_ELEMENT, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_FieldGet(field,farrayPtr=farrayPtr1,rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          !farrayPtr1(1:numElements)=bdys(:,1,sed%export_states(n)%fabm_id+1)
          farrayPtr1(RANGE1D)=bdys(RANGE1D,1,sed%export_states(n)%fabm_id+1)

          write(message, '(A)') trim(name)//' created for import '
          call MOSSCO_FieldString(field, message, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

          call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          if (sed%model%state_variables(sed%export_states(n)%fabm_id)%properties%get_logical( &
              'particulate',default=.false.)) then
            ! overwrite states with fluxes and set z_velocity to -1.0
            call ESMF_FieldGet(field,farrayPtr=farrayPtr1,rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

            farrayPtr1(RANGE1D)=fluxes(RANGE1D,1,sed%export_states(n)%fabm_id)

            field = ESMF_FieldCreate(surface_mesh, &
                   name=trim(sed%export_states(n)%standard_name)//'_z_velocity_at_soil_surface', &
                   typekind=ESMF_TYPEKIND_R8, meshloc=ESMF_MESHLOC_ELEMENT, rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

            call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

            call ESMF_FieldGet(field,farrayPtr=farrayPtr1,rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

            farrayPtr1(RANGE1D)=-1.0_rk

            write(message, '(A)') trim(name)//' created for import '
            call MOSSCO_FieldString(field, message, rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
            call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

            call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
          endif
        endif
      enddo
    else ! sed%grid%use_ugrid
      if (sed%grid%type==LOCAL_GRID) then
        call ESMF_ArraySpecSet(flux_array, rank=2, typekind=ESMF_TYPEKIND_R8, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_ArraySpecSet(state_array, rank=3, typekind=ESMF_TYPEKIND_R8, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        flux_grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/),maxIndex=(/_INUM_,_JNUM_/), &
          regDecomp=(/1,1/),coordSys=ESMF_COORDSYS_SPH_DEG,indexflag=ESMF_INDEX_GLOBAL,  &
          name="sedimentFluxes",coordTypeKind=ESMF_TYPEKIND_R8,coordDep1=(/1/),&
          coorddep2=(/2/),rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_AttributeSet(flux_grid, 'creator', trim(name), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_GridAddCoord(flux_grid, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        ! skip state grid -> use ungridded dimension
        state_grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1,1/),maxIndex=(/_INUM_,_JNUM_,sed%grid%knum/), &
          regDecomp=(/1,1,1/),coordSys=ESMF_COORDSYS_SPH_DEG,indexflag=ESMF_INDEX_GLOBAL,  &
          name="sedimentStates",coordTypeKind=ESMF_TYPEKIND_R8,coordDep1=(/1/),&
          coorddep2=(/2/),rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_AttributeSet(state_grid, 'creator', trim(name), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_GridAddCoord(state_grid, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      endif
      ! by here, have flux_grid available
      call ESMF_GridGet(flux_grid, indexflag=indexflag,rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      ! put concentration array into export state
      ! it might be enough to do this once in initialize(?)
      do n=1,size(sed%export_states)
        field = ESMF_FieldCreate(flux_grid, &
                         typekind=ESMF_TYPEKIND_R8, &
                         name=trim(sed%export_states(n)%standard_name)//'_in_soil', &
                         staggerloc=ESMF_STAGGERLOC_CENTER, &
                         ungriddedLBound=(/1/), ungriddedUBound=(/sed%grid%knum/), &
                         rc=localrc)
                         !gridToFieldMap=(/1,2/), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_AttributeSet(field,'units',trim(sed%export_states(n)%units), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        !> do not set missing value and leave this to netcdf component
        !call ESMF_AttributeSet(field,'missing_value',sed%missing_value, rc=localrc)
        !if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) &
        !  call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
        call ESMF_FieldGet(field=field, farrayPtr=farrayPtr3, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        farrayPtr3 = sed%export_states(n)%data ! initialize with 0.0

        write(message, '(A)') trim(name)//' created for export '
        call MOSSCO_FieldString(field, message, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

        call ESMF_StateAddReplace(exportState,(/field/),rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (sed%export_states(n)%fabm_id/=-1) then
          !> add boundary upward fluxes
          field = ESMF_FieldCreate(flux_grid, &
                         typekind=ESMF_TYPEKIND_R8, &
                         name=trim(sed%export_states(n)%standard_name)//'_upward_flux_at_soil_surface', &
                         staggerloc=ESMF_STAGGERLOC_CENTER,rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          !> fluxes are defined in concentration*m/s
          call ESMF_AttributeSet(field,'units',trim(sed%export_states(n)%units)//'/s')
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farrayPtr2, &
            rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          farrayPtr2 = -fluxes(RANGE2D,sed%export_states(n)%fabm_id)

          write(message, '(A)') trim(name)//' created for export '
          call MOSSCO_FieldString(field, message, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

          call ESMF_StateAddReplace(exportState,(/field/),rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        endif
      enddo
      do n=1,size(sed%model%diagnostic_variables)
        if (sed%model%diagnostic_variables(n)%output /= output_none) then
          diag => sed%diagnostic_variables(n)
          field = ESMF_FieldCreate(flux_grid,farray=diag, &
                   indexflag=indexflag, &
                   ungriddedLBound=(/1/), &
                   ungriddedUBound=(/sed%grid%knum/), &
                   !gridToFieldMap=(/1,2/), &
                   name=only_var_name(sed%model%diagnostic_variables(n)%long_name)//'_in_soil', rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_AttributeSet(field,'units',trim(sed%model%diagnostic_variables(n)%units))
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          write(message, '(A)') trim(name)//' created diagnostic '
          call MOSSCO_FieldString(field, message, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

          call ESMF_StateAddReplace(exportState,(/field/),rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        endif
      enddo

      !> @todo create boundary fields in import State, these used to be empty fields
      !> but regridding needs at least a grid ...

      field = ESMF_FieldEmptyCreate(name='porosity_at_soil_surface', rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_FieldEmptySet(field, grid=flux_grid, staggerloc=ESMF_STAGGERLOC_CENTER, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field,'units','1', rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      write(message, '(A)') trim(name)//' created for import '
      call MOSSCO_FieldString(field, message, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

      call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      field = ESMF_FieldCreate(flux_grid, &
               name='photosynthetically_active_radiation_at_soil_surface', &
               typekind=ESMF_TYPEKIND_R8, staggerloc=ESMF_STAGGERLOC_CENTER, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field,'units','W m-2', rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call MOSSCO_FieldInitialize(field, value=0.0_rk, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      write(message, '(A)') trim(name)//' created for import '
      call MOSSCO_FieldString(field, message, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

      call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

!       ! optionally look light from any model or rate
!       field = ESMF_FieldEmptyCreate(name='downwelling_photosynthetic_radiative_flux_at_soil_surface', rc=localrc)
!       _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
!
!       call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
!       _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
!
!       call ESMF_AttributeSet(field,'units','W m-2', rc=localrc)
!       _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
!
!       write(message, '(A)') trim(name)//' created field'
!       call MOSSCO_FieldString(field, message, rc=localrc)
!       _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
!       call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
!
!       call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
!       _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)


      field = ESMF_FieldCreate(flux_grid, &
               name='temperature_at_soil_surface', &
               typekind=ESMF_TYPEKIND_R8, staggerloc=ESMF_STAGGERLOC_CENTER, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_AttributeSet(field,'units','degreeC', rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call MOSSCO_FieldInitialize(field, value=pel_Temp, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      write(message, '(A)') trim(name)//' created for import '
      call MOSSCO_FieldString(field, message, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

      call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      do n=1,size(sed%export_states)
        if (sed%export_states(n)%fabm_id/=-1) then
          field = ESMF_FieldCreate(flux_grid, &
                   name=trim(sed%export_states(n)%standard_name)//'_at_soil_surface', &
                   typekind=ESMF_TYPEKIND_R8, staggerloc=ESMF_STAGGERLOC_CENTER, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_AttributeSet(field,'units',trim(sed%export_states(n)%units), rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call MOSSCO_FieldInitialize(field, value=0.0_rk, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          write(message, '(A)') trim(name)//' created for export horizontal '
          call MOSSCO_FieldString(field, message, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
          call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

          call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          if (sed%model%state_variables(sed%export_states(n)%fabm_id)%properties%get_logical( &
              'particulate',default=.false.)) then
            field = ESMF_FieldCreate(flux_grid, &
                   name=trim(sed%export_states(n)%standard_name)//'_z_velocity_at_soil_surface', &
                   typekind=ESMF_TYPEKIND_R8, staggerloc=ESMF_STAGGERLOC_CENTER, rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

            call ESMF_AttributeSet(field, 'creator', trim(name), rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

            call ESMF_AttributeSet(field,'units','m s-1', rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

            call MOSSCO_FieldInitialize(field, value=0.0_rk, rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

            write(message, '(A)') trim(name)//' created for export horizontal '
            call MOSSCO_FieldString(field, message, rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
            call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

            call ESMF_StateAddReplace(importState,(/field/),rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
          endif
        endif
      enddo
    endif ! self%use_ugrid
    call get_boundary_conditions(sed,importState,bdys,fluxes)
    !call ESMF_StatePrint(importState)
    !call ESMF_StatePrint(exportState)

    call MOSSCO_CompExit(gridComp, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine InitializeP1


#undef  ESMF_METHOD
#define ESMF_METHOD "InitializeP2"
  subroutine InitializeP2(gridComp, importState, exportState, parentClock, rc)
    implicit none

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    type(ESMF_Clock)            :: clock
    type(ESMF_Time)             :: currTime
    integer(ESMF_KIND_I4)       :: localrc
    character(len=ESMF_MAXSTR)  :: name, message, itemname

    integer(ESMF_KIND_I4)          :: ubnd(2),lbnd(2), rank
    real(ESMF_KIND_R8), pointer    :: farrayPtr2(:,:), farrayPtr1(:)
    type(ESMF_FieldStatus_Flag)    :: fieldstatus
    type(ESMF_StateItem_Flag)      :: itemtype
    type(ESMF_Field)               :: field
    real(ESMF_KIND_R8)             :: defaultValue
    logical                        :: isPresent

    type(ESMF_GeomType_Flag)       :: geomType
    type(ESMF_Field), allocatable  :: fieldList(:)
    integer(ESMF_KIND_I4)          :: fieldCount
    type(ESMF_MeshLoc)             :: meshLoc

    !> here: * @todo: evtl. complete fields here
    !!       * check for porosity in importState and copy data
    !!       * check initialize_variables_method for:
    !!         a) set constant values
    !!         b) presimulate after setting constant values
    !!         c) copy 3d data for restarting previous simulation

    call MOSSCO_CompEntry(gridComp, parentClock, name=name, currTime=currTime, &
      importState=importState, exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    ubnd(1:2) = 1
    lbnd(1:2) = 1
    itemType = ESMF_STATEITEM_NOTFOUND
    isPresent = .false.

    !> check for porosit
    itemName = 'porosity_at_soil_surface'
    call MOSSCO_StateGet(importState, fieldList, fieldCount=fieldCount, &
      itemSearch=itemName, fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/), &
      rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (fieldCount > 0) then

      call ESMF_FieldGet(fieldList(1), rank=rank, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (rank == 2) then
        call ESMF_FieldGet(fieldList(1), farrayPtr=farrayPtr2, &
          exclusiveUBound=ubnd, exclusiveLBound=lbnd, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        sed%porosity(RANGE2D,1) = farrayPtr2(RANGE2D)

      elseif (rank == 1) then

        call ESMF_FieldGet(fieldList(1), geomType=geomType, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (geomType == ESMF_GEOMTYPE_MESH) then
          call ESMF_FieldGet(fieldList(1), meshLoc=meshloc, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        endif

        call ESMF_FieldGet(fieldList(1), farrayPtr=farrayPtr1, &
          exclusiveUBound=ubnd(1:1), exclusiveLBound=lbnd(1:1), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        sed%porosity(RANGE1D,lbnd(1),1)=farrayPtr1(RANGE1D)
      endif
    ! else
    !
    !   call ESMF_StateGet(importState, itemName, itemType=itemtype, rc=localrc)
    !   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    !
    !   if (itemType == ESMF_STATEITEM_FIELD) then
    !
    !     call ESMF_StateGet(importState, itemName, field=field, rc=localrc)
    !     _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    !
    !     call ESMF_AttributeGet(field, 'default_value', defaultValue, &
    !       defaultValue=-1D30, isPresent=isPresent, rc=localrc)
    !     _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    !
    !     ! if (isPresent) then
    !     !   sed%porosity(RANGE2D,1)=defaultValue
    !     ! else
    !     !   write(message,'(A)') trim(name)//' removed and destroyed '
    !     !   call MOSSCO_FieldString(fieldList(1), message, rc=localrc)
    !     !   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    !     !   call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
    !     !   call ESMF_StateRemove(importState,(/trim(itemname)/), rc=localrc)
    !     !   call ESMF_FieldDestroy(fieldList(1), rc=localrc)
    !     ! endif
    !   endif
    endif
    !
    ! if (fieldCount > 0 .or. (itemType == ESMF_STATEITEM_FIELD .and. isPresent)) then
    !   call sed%update_porosity(from_surface=.true.)
    !   write(message,'(A)') trim(name)//' updated porosity from'
    !   call MOSSCO_FieldString(fieldList(1), message, rc=localrc)
    !   _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    !   call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
    ! else
    !   write(message,'(A)') trim(name)//' has no external porosity information'
    !   call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
    ! endif

    call MOSSCO_CompExit(gridComp, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine InitializeP2

#undef  ESMF_METHOD
#define ESMF_METHOD "ReadRestart"
  subroutine ReadRestart(gridComp, importState, exportState, parentClock, rc)

    implicit none

    type(ESMF_GridComp)   :: gridComp
    type(ESMF_State)      :: importState
    type(ESMF_State)      :: exportState
    type(ESMF_Clock)      :: parentClock
    integer, intent(out)  :: rc

    character(len=ESMF_MAXSTR)  :: name, message, varname, component_name, creator_name
    type(ESMF_Time)             :: currTime
    integer                     :: localrc,n, rank

    integer(ESMF_KIND_I4)          :: ubnd(3),lbnd(3)!,ownshape(3)
    integer(ESMF_KIND_I4)          :: exportUbnd(3),exportLbnd(3),ownshape(3)
    real(ESMF_KIND_R8), pointer    :: farrayPtr3(:,:,:)
    type(ESMF_FieldStatus_Flag)    :: fieldstatus
    type(ESMF_StateItem_Flag)      :: itemtype
    type(ESMF_Field)               :: field, exportField

    rc = ESMF_SUCCESS

    call MOSSCO_CompEntry(gridComp, parentClock, name=name, currTime=currTime, &
      importState=importState, exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_StateGet(importState, name=component_name, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    write(message,'(A)') trim(name)//' scan for variables in component '//trim(component_name)
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    !> browse through list of state variables and
    !! copy data from importState fields with same name
    do n = 1, size(sed%export_states)

      varname=trim(sed%export_states(n)%standard_name)//'_in_soil'
      call ESMF_StateGet(importState, trim(varname), itemType=itemType, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (itemType == ESMF_STATEITEM_NOTFOUND) then
        write(message,'(2x,''('',i2.2,'') '',A)') n, trim(varname)//' has itemType ESMF_STATEITEM_NOTFOUND'
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
        cycle
      endif

      if (itemType /= ESMF_STATEITEM_FIELD) then
        write(message,'(A)') trim(name)//' skipped hotstart for non-field '//trim(varname)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
        call MOSSCO_StateLog(importState, rc=localrc)
        cycle
      endif

      call ESMF_StateGet(importState, trim(varname), field=field, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_FieldGet(field, status=fieldstatus, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (fieldstatus /= ESMF_FIELDSTATUS_COMPLETE) then
        write(message,'(A)') trim(name)//' skipped hotstart for incomplete '
        call MOSSCO_FieldString(field, message, rc=localrc)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_WARNING)
        cycle
      endif

      call ESMF_FieldGet(field, rank=rank, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (rank /= 3) then
        write(message,'(A)') trim(name)//' skipped hotstart for not rank 3 '
        call MOSSCO_FieldString(field, message, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_WARNING)
        cycle
      endif

      call ESMF_FieldGet(field, farrayPtr=farrayPtr3, &
        exclusiveUBound=ubnd, exclusiveLBound=lbnd, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      !! Need to get shape from exportState field of same name to constrain the indices
      !! of the conc field
      call ESMF_StateGet(exportState, trim(varname), itemType=itemType, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_StateGet(exportState, trim(varname), field=exportfield, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_FieldGetBounds(exportField, exclusiveUbound=exportUbnd, &
        exclusiveLbound=exportLbnd, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (any (exportUbnd /= ubnd) .or. any(exportLbnd /= lbnd)) then
        write(message,'(A)') trim(name)//' skipped hotstart for no-match array bounds '
        call MOSSCO_FieldString(field, message, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_WARNING)
        cycle
      endif

      ! ownshape = shape(sed%export_states(n)%data)
      !
      ! if ((ubnd(1)-lbnd(1)+1.ne.ownshape(1)).or. &
      !         (ubnd(2)-lbnd(2)+1.ne.ownshape(2)).or. &
      !         (ubnd(3)-lbnd(3)+1.ne.ownshape(3))) then
      !       write(message,'(A)') trim(name)//' incompatible shape of field'
      !       call mossco_fieldString(field, message)
      !       call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
      !       write(message,'(A,4I3,A,4I3)') trim(name)//' own shape', ownshape, ' other shape ', &
      !         ubnd(:)-lbnd(:)+ (/1,1,1/)
      !       call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR)
      !       call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
      ! endif
#ifdef DEBUG
          if (trim(varname) == 'porosity_in_soil') then
            write(0,*) 'debugging output just before restart update of porosity_in_soil'
            write(0,*) 'farrayPtr3',shape(farrayPtr3),lbound(farrayPtr3),farrayPtr3(RANGE1D,lbnd(2),1)
            write(0,*) 'export',sed%export_states(n)%data(:,lbnd(2),1)
            write(0,*) 'mask',sed%mask(RANGE1D,lbnd(2),1)
            write(0,*) 'porosity',sed%porosity(RANGE1D,lbnd(2),1)
          endif
#endif
        !   sed%export_states(n)%data = farrayPtr3
        !   write(message,'(A)') trim(name)//' hotstarted field'
        !   call mossco_fieldString(field, message)
        !   call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
        ! else
        !   write(message,'(A)') trim(name)//' incomplete field'
        !   call mossco_fieldString(field, message)
        !   call ESMF_LogWrite(trim(message),ESMF_LOGMSG_WARNING)
        ! endif
      !endif

      sed%export_states(n)%data(exportLbnd(1):exportUBnd(1),exportLbnd(2):exportUbnd(2), &
        exportLBnd(3):exportUBnd(3)) = farrayPtr3(lbnd(1):ubnd(1),lbnd(2):ubnd(2),lbnd(3):ubnd(3))

      !> update FABM_sediment export states pointers
      call ESMF_StateGet(exportState, trim(varname), field=field, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farrayPtr3, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      farrayPtr3 = sed%export_states(n)%data
      !> @todo: add bounds checking?

      write(message,'(A)') trim(name)//' hotstarted '
      call MOSSCO_FieldString(field, message, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
    enddo

    !call sed%update_export_states()
    !> check for valid grid and porosity
#ifdef DEBUG
    write(0,*) 'fabm_sediment ReadRestart: check domain'
#endif
    call sed%check_domain()

    call MOSSCO_CompExit(gridComp, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine ReadRestart

#undef  ESMF_METHOD
#define ESMF_METHOD "Run"
  subroutine Run(gridComp, importState, exportState, parentClock, rc)

    implicit none

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(len=19) :: timestring1,timestring2
    type(ESMF_Time)   :: wallTime, clockTime
    type(ESMF_TimeInterval) :: timeInterval
    type(ESMF_Grid)   :: grid
    type(ESMF_Field), allocatable, dimension(:) :: fieldlist
    type(ESMF_Field)  :: field
    real(ESMF_KIND_R8),pointer,dimension(:,:) :: farrayPtr2
    real(ESMF_KIND_R8),pointer,dimension(:,:,:) :: farrayPtr3
    integer           :: fieldcount, i, j, k
    character(len=ESMF_MAXSTR)  :: string
    type(ESMF_Alarm)           :: outputAlarm

    character(len=ESMF_MAXSTR) :: timestring, name, message, varname
    integer(ESMF_KIND_I4)      :: localPet, petCount, itemCount
    type(ESMF_Clock)           :: clock
    type(ESMF_Time)            :: currTime, startTime, stopTime
    integer(ESMF_KIND_I8)      :: seconds, advanceCount
    type(ESMF_TimeInterval)    :: timeStep
    logical                    :: clockIsPresent

    type(ESMF_Alarm), allocatable :: alarmList(:)
    integer(ESMF_KIND_I4)      :: alarmCount
    character(len=ESMF_MAXSTR) :: alarmName
    integer(ESMF_KIND_I4)      :: localrc

    type(ESMF_StateItem_Flag)   :: itemType
    type(ESMF_FieldStatus_Flag) :: fieldStatus
    character(len=ESMF_MAXSTR)  :: itemName
    integer(ESMF_KIND_I4)       :: lbnd(2), ubnd(2), rank
    character(len=ESMF_MAXSTR), pointer  :: includelist(:) => null()
    type(ESMF_GeomType_Flag)    :: geomType
    type(ESMF_MeshLoc)          :: meshLoc
    real(ESMF_KIND_R8),dimension(:),pointer  :: farrayPtr1

    call MOSSCO_CompEntry(gridComp, parentClock, name=name, currTime=currTime, &
      importState=importState, exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    ubnd(1:2) = 1
    lbnd(1:2) = 1

!    !> check for PAR
!    allocate( includelist(1) )
!    includelist(1) = 'photosynthetically_active_radiation_at_soil_surface'
!    !includelist(2) = 'bottom_downwelling_photosynthetic_radiative_flux'
!    call MOSSCO_StateGet(importState, fieldList=fieldList, &
!      fieldCount=fieldCount, fieldStatusList=(/ESMF_FIELDSTATUS_COMPLETE/), rc=localrc)
!    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
!    nullify(includelist)
!
!    if (fieldCount>0) then
!      call ESMF_FieldGet(fieldlist(1), farrayPtr=farrayPtr2, &
!        exclusiveUBound=ubnd, exclusiveLBound=lbnd, rc=localrc)
!      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
!
!      sed%par_surface(RANGE2D_)=farrayPtr2(lbnd(1):ubnd(1),lbnd(2):ubnd(2))
!      write(message,'(A)') trim(name)//' updated par_surface from'
!      call MOSSCO_FieldString(field, message, rc=localrc)
!      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
!      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
!    else
!       write(message,'(A)') trim(name)//' has no external surface radiation information'
!       call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
!    endif

    !> check for PAR
    itemname='photosynthetically_active_radiation_at_soil_surface'
    call ESMF_StateGet(importState, trim(itemname), itemType=itemType, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (itemType==ESMF_STATEITEM_FIELD) then
      call ESMF_StateGet(importState, trim(itemname), field=field, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_FieldGet(field, status=fieldstatus, geomType=geomType, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (geomType == ESMF_GEOMTYPE_MESH) then
        call ESMF_FieldGet(field, meshloc=meshloc, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      endif

      if (fieldstatus==ESMF_FIELDSTATUS_COMPLETE) then

        if (geomType == ESMF_GEOMTYPE_MESH .and. meshloc == ESMF_MESHLOC_ELEMENT) then
          call ESMF_FieldGet(field, farrayPtr=farrayPtr2, &
            computationalUBound=ubnd, computationalLBound=lbnd, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        else
          call ESMF_FieldGet(field, farrayPtr=farrayPtr2, &
            exclusiveUBound=ubnd, exclusiveLBound=lbnd, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        endif

        sed%par_surface(RANGE2D)=farrayPtr2(RANGE2D)
        write(message,'(A)') trim(name)//' updated par_surface from'
        call MOSSCO_FieldString(field, message, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
      else
        write(message,'(A)') trim(name)//' received incomplete field'
        call mossco_fieldString(field, message)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_WARNING)

        call MOSSCO_StateLog(importState, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call MOSSCO_StateLog(exportState, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      end if
    else
      write(message,'(A)') trim(name)//' has no external surface radiation information'
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
    end if

    !> check for porosity
    itemname='porosity_at_soil_surface'
    call ESMF_StateGet(importState, trim(itemname), itemType=itemType, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (itemType==ESMF_STATEITEM_FIELD) then
      call ESMF_StateGet(importState, trim(itemname), field=field, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_FieldGet(field, status=fieldstatus, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (fieldstatus==ESMF_FIELDSTATUS_COMPLETE) then

        if (geomType == ESMF_GEOMTYPE_MESH .and. meshloc == ESMF_MESHLOC_ELEMENT) then
          call ESMF_FieldGet(field, farrayPtr=farrayPtr2, &
            computationalUBound=ubnd, computationalLBound=lbnd, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        else
          call ESMF_FieldGet(field, farrayPtr=farrayPtr2, &
            exclusiveUBound=ubnd, exclusiveLBound=lbnd, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        endif

        sed%porosity(RANGE2D,1)=farrayPtr2(RANGE2D)
        call sed%update_porosity(from_surface=.true.)
        write(message,'(A)') trim(name)//' updated porosity from'
        call MOSSCO_FieldString(field, message, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
      else
        write(message,'(A)') trim(name)//' received incomplete field'
        call mossco_fieldString(field, message)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_WARNING)

        call MOSSCO_StateLog(importState, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call MOSSCO_StateLog(exportState, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      endif
    else
      write(message,'(A)') trim(name)//' has no external porosity information'
      call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)
    endif

    call get_boundary_conditions(sed, importState, bdys, fluxes)
    sed%bdys   => bdys
    sed%fluxes => fluxes

    call ESMF_GridCompGet(gridComp, clock=clock, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_ClockGet(clock, alarmCount=alarmCount, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (alarmCount>0) then
      if (.not.allocated(alarmList)) allocate(alarmList(alarmCount))
      call ESMF_ClockGetAlarmList(clock, ESMF_ALARMLIST_ALL, alarmList=alarmList, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      do i=1,alarmCount
        call ESMF_AlarmGet(alarmList(i), name=alarmName, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        if (trim(alarmName)=='outputAlarm') then
           outputAlarm=alarmList(i)
           exit
        endif
      enddo
    endif

    call ESMF_GridCompGet(gridComp, clock=clock, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_ClockGet(clock, stopTime=stopTime, currTime=currTime, timeStep=timeStep, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    call ESMF_TimeIntervalGet(timeStep, s_r8=dt, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    do while (.not.ESMF_ClockIsStopTime(clock))

      call ESMF_ClockGet(clock, currTime=currTime, advanceCount=advanceCount, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      if (currTime + timeStep > stopTime) then
        timeStep=stopTime-currTime
        call ESMF_TimeIntervalGet(timeStep, s_r8=dt, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      endif

      !write(0,*) 1171,trim(name)
      !> @todo the solver is not stable in example xf with sns topo

      ! integrate rates
      call ode_solver(sed, dt, ode_method)

      !check for NaN
      call check_NaN(sed,rc=localrc)
      if (rc == ESMF_RC_VAL_OUTOFRANGE ) then
        write(message,'(A)')  '  NaN detected applying ode_solver'
        call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
        call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
      endif

      ! reset concentrations to mininum_value
      if (_INUM_ > 0 .and. _JNUM_ > 0)  then
        do n=1,sed%nvar
          where (sed%conc(RANGE3D,n) .lt. sed%model%state_variables(n)%minimum)
            sed%conc(RANGE3D,n) = sed%model%state_variables(n)%minimum
          endwhere
        enddo
      endif

      if (sed%do_output) then
        !! Check if the output alarm is ringing, if so, quiet it and
        !! get the current advance count from clock
        !if (ESMF_AlarmIsRinging(outputAlarm)) then
        !  call ESMF_AlarmRingerOff(outputAlarm,rc=localrc)
        if (mod(advanceCount,output)==0) then
          !write(string,'(A,F7.1,A)') 'Elapsed ',advanceCount*dt/86400,' days'
          !write(*,'(A,F7.1,A)') 'Elapsed ',advanceCount*dt/86400,' days'
          !call ESMF_LogWrite(string,ESMF_LOGMSG_INFO)
          write(funit,*) advanceCount*dt,'fluxes',fluxes(1,1,:)
          do k=1,_KNUM_
            write(funit,FMT='(E15.3,A,E15.4E3,A,E15.4E3,A,E15.4E3)',advance='no') &
              advanceCount*dt,' ',sed%grid%zc(lbnd(1),lbnd(2),k),' ',&
              sed%grid%dz(lbnd(1),lbnd(2),k),  &
              ' ',sed%porosity(lbnd(1),lbnd(2),k)
            do n=1,sed%nvar
              write(funit,FMT='(A,E15.4E3)',advance='no') ' ',conc(lbnd(1),lbnd(2),k,n)
            enddo
            do n=1,size(sed%model%diagnostic_variables)
              diag => sed%diagnostic_variables(n)
              write(funit,FMT='(A,E15.4E3)',advance='no') ' ',diag(lbnd(1),lbnd(2),k)
            enddo
            write(funit,*)
          enddo
        endif
      endif



#ifdef WRITE_PROGRESS
      if (mod(advanceCount*dt,(365.*86400.)).eq.0) write(0,*) '  elapsed [d]',dt*advanceCount/86400.
#endif

      call ESMF_ClockAdvance(clock, timeStep=timeStep, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    enddo

    ! write back fluxes into export State

    do n=1,size(sed%export_states)
      if (sed%grid%use_ugrid) then
        call ESMF_StateGet(exportState, &
             trim(sed%export_states(n)%standard_name)//'_in_soil', &
             field,rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_FieldGet(field=field, localDe=0, farrayPtr=statemesh_ptr, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        !write(0,*) 'statemesh ',shape(statemesh_ptr), 'data ',shape(sed%export_states(n)%data)

        do k=1,sed%grid%knum
          statemesh_ptr(RANGE1D,k) = sed%export_states(n)%data(RANGE1D,lbnd(1),k)
        enddo

        if (sed%export_states(n)%fabm_id /= -1) then
          call ESMF_StateGet(exportState, &
             trim(sed%export_states(n)%standard_name)//'_upward_flux_at_soil_surface', &
             field,rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farrayPtr1, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          farrayPtr1(RANGE1D) = -fluxes(RANGE1D,lbnd(2),sed%export_states(n)%fabm_id)
        endif
      else
        call ESMF_StateGet(exportState, &
             trim(sed%export_states(n)%standard_name)//'_in_soil', &
             field,rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farrayPtr3, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

        farrayPtr3 = sed%export_states(n)%data
        if (sed%export_states(n)%fabm_id /= -1) then
          call ESMF_StateGet(exportState, &
             trim(sed%export_states(n)%standard_name)//'_upward_flux_at_soil_surface', &
             field,rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farrayPtr2, rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

          farrayPtr2(RANGE2D) = -fluxes(RANGE2D,sed%export_states(n)%fabm_id)
        endif
      endif ! sed%grid%use_ugrid
    enddo

    if (allocated(fieldList)) deallocate(fieldlist)

    call MOSSCO_CompExit(gridComp, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine Run

#undef  ESMF_METHOD
#define ESMF_METHOD "Finalize"
  subroutine Finalize(gridComp, importState, exportState, parentClock, rc)

    type(ESMF_GridComp)   :: gridComp
    type(ESMF_State)      :: importState, exportState
    type(ESMF_Clock)      :: parentClock
    integer, intent(out)  :: rc

    integer(ESMF_KIND_I4)   :: petCount, localPet
    character(ESMF_MAXSTR)  :: name, message, timeString
    logical                 :: clockIsPresent
    type(ESMF_Time)         :: currTime
    type(ESMF_Clock)        :: clock
    integer(ESMF_KIND_I4)      :: localrc

    call MOSSCO_CompEntry(gridComp, parentClock, name=name, currTime=currTime, importState=importState, &
      exportState=exportState, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    close(funit)

    call sed%finalize()
    if (allocated(conc)) deallocate(conc)
    if (allocated(bdys)) deallocate(bdys)
    if (allocated(fluxes)) deallocate(fluxes)

    call MOSSCO_CompExit(gridComp, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

  end subroutine Finalize

#undef  ESMF_METHOD
#define ESMF_METHOD "get_boundary_conditions"
  subroutine get_boundary_conditions(sed, importState, bdys, fluxes, verbose, rc)

    real(rk),dimension(:,:,:),target :: bdys,fluxes
    type(type_sed)      :: sed
    type(ESMF_State)    :: importState
    logical, intent(in), optional :: verbose
    integer(ESMF_KIND_I4), intent(out), optional :: rc

    real(ESMF_KIND_R8),pointer,dimension(:,:)  :: farrayPtr2,ptr_vs_2d
    real(ESMF_KIND_R8),pointer,dimension(:,:,:)  :: farrayPtr3,ptr_vs
    type(ESMF_Field)    :: field,vs_field
    type(ESMF_Array)    :: array,vs_array
    integer             :: n, fieldCount
    character(len=ESMF_MAXSTR) :: string
    character(len=ESMF_MAXSTR) :: varname
    real(rk),dimension(_IRANGE_,_JRANGE_),target :: vs,pom
    integer(ESMF_KIND_I4)      :: localrc, itemCount

    type(ESMF_Field), allocatable      :: fieldList(:)
    logical                            :: verbose_
    integer(ESMF_KIND_I4)              :: rc_, rank
    integer(ESMF_KIND_I4)              :: lbnd(2), ubnd(2)
    type(ESMF_GeomType_Flag)           :: geomType
    type(ESMF_MeshLoc)                 :: meshLoc

    rc_ = ESMF_SUCCESS
    verbose_ = .false.
    meshloc = ESMF_MESHLOC_ELEMENT
    lbnd(1:2) = 1
    ubnd(1:2) = 1

    if (present(rc)) rc = rc_
    if (present(verbose)) verbose_ = verbose

    call MOSSCO_StateGet(importState, fieldList, fieldCount=fieldCount, &
      itemSearch='temperature_at_soil_surface', verbose=verbose, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (fieldCount > 0) then
      call ESMF_FieldGet(fieldList(1), rank=rank, geomType=geomType, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

      if (geomType == ESMF_GEOMTYPE_MESH) then
        call ESMF_FieldGet(fieldList(1), meshloc=meshloc, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
      endif

      if (geomType == ESMF_GEOMTYPE_MESH .and. meshloc == ESMF_MESHLOC_ELEMENT) then
        call ESMF_FieldGetBounds(fieldList(1), localDe=0, computationalLBound=lbnd(1:1), &
          computationalUBound=ubnd(1:1), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
      elseif (rank == 1) then
        call ESMF_FieldGetBounds(fieldList(1), localDe=0, exclusiveLBound=lbnd(1:1), &
          exclusiveUBound=ubnd(1:1), rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
      elseif (rank == 2) then
        call ESMF_FieldGetBounds(fieldList(1), localDe=0, exclusiveLBound=lbnd, &
          exclusiveUBound=ubnd, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
      endif

      if (rank == 1) then
        call ESMF_FieldGet(fieldList(1), farrayPtr=farrayPtr1, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

        bdys(RANGE1D,1,1) = farrayPtr1(RANGE1D)
      else
        call ESMF_FieldGet(fieldList(1), farrayPtr=farrayPtr2, rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

        bdys(RANGE2D,1) = farrayPtr2(RANGE2D)
      endif
    endif

    if (sed%bcup_dissolved_variables .gt. 0) then
    do n=1,sed%nvar
      if (sed%model%state_variables(n)%standard_variable%name/='') then
        varname = &
          trim(sed%model%state_variables(n)%standard_variable%name)
      else
      !> otherwise use CF-ed version of long_name
        varname = trim(only_var_name( &
           sed%model%state_variables(n)%long_name))
      endif
      call ESMF_StateGet(importState,itemSearch=trim(varname)//'_at_soil_surface', &
                         itemCount=itemcount,rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

      if (itemcount==0) then
#ifdef DEBUG
        write(string,'(A)') "Variable '"//trim(varname)//"' not found in State. Skipping."
        call ESMF_LogWrite(string,ESMF_LOGMSG_INFO)
#endif
      else
        call ESMF_StateGet(importState,trim(varname)//'_at_soil_surface',field,rc=localrc)
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
#ifdef DEBUG
        if (localrc == ESMF_SUCCESS) write(0,*) 'found field ',trim(varname)
#endif

        if (sed%model%state_variables(n)%properties%get_logical( &
            'particulate',default=.false.)) then
          !write(0,*) 'try to get ',trim(varname)//'_z_velocity'
          call ESMF_StateGet(importState,trim(varname)//'_z_velocity_at_soil_surface', vs_field,rc=localrc)
          _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

          if (sed%grid%use_ugrid) then
            call ESMF_FieldGet(fieldList(1),farrayPtr=farrayPtr1,rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

            call ESMF_FieldGet(vs_field,farrayPtr=farrayPtr1_vs,rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

            fluxes(RANGE1D,1,n) = -farrayPtr1(RANGE1D)*farrayPtr1_vs(RANGE1D) ! downward flux is positive
          else
            call ESMF_FieldGet(field,farrayPtr=farrayPtr2,rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

            call ESMF_FieldGet(vs_field,farrayPtr=ptr_vs_2d,rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

            fluxes(RANGE2D,n) = -farrayPtr2(RANGE2D)*ptr_vs_2d(RANGE2D) ! downward flux is positive
          endif
#ifdef DEBUG
          write(0,*) '  flux',-fluxes(1,1,n)
#endif
        else
          farrayPtr2 => bdys(:,:,n+1)
          if (sed%grid%use_ugrid) then
            call ESMF_FieldGet(field,farrayPtr=farrayPtr1,rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

            farrayPtr2(:,1) = farrayPtr1(:)
          else
            call ESMF_FieldGet(field, farrayPtr=farrayPtr2, rc=localrc)
            _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

            bdys(RANGE2D,n+1) = farrayPtr2(RANGE2D)
          endif
          if (sed%bcup_dissolved_variables .eq. 1) then

!            call ESMF_StateGet(exportState, trim(varname), field=exportfield, rc=localrc)

!            call mossco_state_get(exportState, &
!        (/'turbulent_kinetic_energy_at_soil_surface'/), tke, verbose=verbose, rc=localrc)
!tke(lbnd(1):ubnd(1),lbnd(2):ubnd(2))

            fluxes(RANGE2D,n) = -(sed%conc(RANGE2D,1,n)-bdys(RANGE2D,n+1))/ &
              sed%grid%dz(RANGE2D,1)*(sed%bioturbation + sed%diffusivity+bdys(RANGE2D,1) * &
              0.035d0)*sed%porosity(RANGE2D,1)/86400._rk/10000._rk
          else
            !> reset fluxes to zero
            fluxes(RANGE2D,n) = 0.0d0
          endif
#ifdef DEBUG
          write(0,*) '  bdys',farrayPtr2(1,1)
#endif
        endif !if "particulate"
      endif !if (itemcount==0)
    enddo !do n=1,sed%nvar
    endif !if (sed%bcup_dissolved_variables .gt. 0)

  end subroutine get_boundary_conditions

#undef  ESMF_METHOD
#define ESMF_METHOD "read_config"
!> Read the associated .cfg resource file and save its parameters in
!> the component's attributes
  subroutine read_config(gridComp, kwe, rc)

    implicit none

    type(ESMF_GridComp), intent(inout)               :: gridComp
    type(ESMF_KeyWordEnforcer), intent(in), optional :: kwe
    integer(ESMF_KIND_I4), intent(out), optional     :: rc

    integer(ESMF_KIND_I4)             :: rc_, localRc
    character(len=ESMF_MAXSTR)        :: configFileName, message
    character(len=ESMF_MAXSTR)        :: gridCompName
    logical                           :: labelIsPresent, fileIsPresent
    logical                           :: configIsPresent, configFileIsPresent
    type(ESMF_Config)                 :: config

    rc_ = ESMF_SUCCESS
    if (present(kwe)) rc_ = ESMF_SUCCESS
    if (present(rc)) rc = rc_

    call ESMF_GridCompGet(gridComp, configIsPresent=configIsPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (configIsPresent) then
      call ESMF_GridCompGet(gridComp, configIsPresent=configIsPresent, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    else
      config = ESMF_ConfigCreate(rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

      call ESMF_GridCompSet(gridComp, config=config, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
    endif

    call ESMF_GridCompGet(gridComp, configFileIsPresent=configFileIsPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call ESMF_GridCompGet(gridComp, name=gridCompName, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (configFileIsPresent) then
      call ESMF_GridCompGet(gridComp, configFile=configFileName, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    else
      configFileName=trim(gridCompName)//'.cfg'
    endif

    inquire(file=trim(configfilename), exist=fileIsPresent)
    if (.not. fileIsPresent) then
      configFileName = 'fabm_sediment.cfg'
      inquire(file=trim(configfilename), exist=fileIsPresent)
    endif
    if (.not. fileIsPresent) then
      configFileName = 'fabm_sediment.cfg'
      inquire(file=trim(configfilename), exist=fileIsPresent)
    endif
    if (.not. fileIsPresent) return

    write(message,'(A)')  trim(gridCompName)//' reads configuration from '//trim(configFileName)
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

    call ESMF_ConfigLoadFile(config, trim(configfilename), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_ConfigGet(config, label='dt', value=dt, &
      defaultValue=720.0d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item dt = ',dt
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      call ESMF_AttributeSet(gridComp, 'timestep', dt, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    endif

    call MOSSCO_ConfigGet(config, label='dt_min', value=dt_min, &
      defaultValue=1.0d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item dt_min = ',dt_min
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      call ESMF_AttributeSet(gridComp, 'minimum_timestep', dt_min, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    endif

    call MOSSCO_ConfigGet(config, label='numlayers', value=numlayers, &
      defaultValue=15, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_ConfigGet(config, label='dzmin', value=dzmin, &
      defaultValue=0.004d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item dzmin = ',dzmin
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      call ESMF_AttributeSet(gridComp, 'minimum_layer_height', dzmin, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    endif

    call MOSSCO_ConfigGet(config, label='ode_method', value=ode_method, &
      defaultValue=_ADAPTIVE_EULER_, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_ConfigGet(config, label='relative_change_min', value=relative_change_min, &
      defaultValue=-0.9d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item relative_change_min = ',relative_change_min
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      call ESMF_AttributeSet(gridComp, 'relative_change_min', relative_change_min, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    endif

    call MOSSCO_ConfigGet(config, label='ugrid_name', value=ugrid_name, &
      defaultValue='', isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    !> Find out whether the label was specified.  If yes, then require
    !> the file to be present, and return if not found
    inquire(file=trim(ugrid_name), exist=fileIsPresent)

    if (labelIsPresent .and..not. fileIsPresent) then
      write(message, '(A)') trim(gridCompName)//' cannot find '//trim(ugrid_name)
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_ERROR)
      if (present(rc)) then
        rc = ESMF_RC_FILE_OPEN
        return
      else
        localrc = ESMF_RC_FILE_OPEN
        _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
      endif
    endif

    call MOSSCO_ConfigGet(config, label='presimulation_years', &
      value=presimulation_years, &
      defaultValue=2, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_ConfigGet(config, label='bcup_dissolved_variables', &
      value=bcup_dissolved_variables, &
      defaultValue=2, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_ConfigGet(config, label='pel_Temp', value=pel_Temp, &
      defaultValue=5.0d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item pel_Temp = ',pel_Temp
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      call ESMF_AttributeSet(gridComp, 'boundary_temperature', pel_Temp, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    endif

    call MOSSCO_ConfigGet(config, label='pel_NO3', value=pel_NO3, &
      defaultValue=5.0d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item pel_NO3 = ',pel_NO3
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      call ESMF_AttributeSet(gridComp, 'boundary_nitrate', pel_NO3, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    endif

    call MOSSCO_ConfigGet(config, label='pel_NH4', value=pel_NH4, &
      defaultValue=5.0d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item pel_NH4 = ',pel_NH4
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      call ESMF_AttributeSet(gridComp, 'boundary_ammonium', pel_NH4, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    endif

    call MOSSCO_ConfigGet(config, label='pel_PO4', value=pel_PO4, &
      defaultValue=0.5d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item pel_PO4 = ',pel_PO4
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
      call ESMF_AttributeSet(gridComp, 'boundary_phosphate', pel_PO4, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)
    endif

    call MOSSCO_ConfigGet(config, label='pel_O2', value=pel_NO3, &
      defaultValue=250.0d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item pel_PO4 = ',pel_PO4
    else
      write(message,'(A,ES9.2)') trim(gridCompName)// ' uses default pel_PO4 = ',pel_PO4
    endif
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
    call ESMF_AttributeSet(gridComp, 'boundary_phosphate', pel_PO4, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_ConfigGet(config, label='pflux_lDetC', value=pflux_lDetC, &
      defaultValue=10.0d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    !> For legacy reasons allow "l"abile carbon to be specified as "f"ast
    if (.not.labelIsPresent) then
      call MOSSCO_ConfigGet(config, label='pflux_fDet', value=pflux_lDetC, &
        defaultValue=10.0d0, isPresent=labelIsPresent, rc = localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

      if (labelIsPresent) then
        write(message,'(A)') trim(gridCompName)// ' found deprecated config item pflux_fDet, please use pflux_lDetC.'
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
      endif
    endif

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item pflux_lDetC = ',pflux_lDetC
    else
      write(message,'(A,ES9.2)') trim(gridCompName)// ' uses default pflux_lDetC = ',pflux_lDetC
    endif
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
    call ESMF_AttributeSet(gridComp, 'boundary_labile_carbon_flux', pflux_lDetC, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_ConfigGet(config, label='pflux_sDetC', value=pflux_sDetC, &
      defaultValue=10.0d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    !> For legacy reasons allow sDet instead of sDetC
    if (.not.labelIsPresent) then
      call MOSSCO_ConfigGet(config, label='pflux_sDet', value=pflux_sDetC, &
        defaultValue=10.0d0, isPresent=labelIsPresent, rc = localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

      if (labelIsPresent) then
        write(message,'(A)') trim(gridCompName)// ' found deprecated config item pflux_sDet, please use pflux_sDetC.'
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
      endif
    endif

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item pflux_sDetC = ',pflux_sDetC
    else
      write(message,'(A,ES9.2)') trim(gridCompName)// ' uses default pflux_sDetC = ',pflux_sDetC
    endif
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
    call ESMF_AttributeSet(gridComp, 'boundary_semilabile_carbon_flux', pflux_sDetC, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_ConfigGet(config, label='pflux_lDetN', value=pflux_lDetN, &
      defaultValue=1.5d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item pflux_lDetN = ',pflux_lDetN
    else
      write(message,'(A,ES9.2)') trim(gridCompName)// ' uses default pflux_lDetN = ',pflux_lDetN
    endif
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
    call ESMF_AttributeSet(gridComp, 'boundary_labile_nitrogen_flux', pflux_lDetN, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_ConfigGet(config, label='pflux_sDetN', value=pflux_sDetN, &
      defaultValue=1.5d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item pflux_sDetN = ',pflux_sDetN
    else
      write(message,'(A,ES9.2)') trim(gridCompName)// ' uses default pflux_sDetN = ',pflux_sDetN
    endif
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
    call ESMF_AttributeSet(gridComp, 'boundary_semilabile_nitrogen_flux', pflux_sDetN, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    call MOSSCO_ConfigGet(config, label='pflux_lDetP', value=pflux_lDetP, &
      defaultValue=0.2d0, isPresent=labelIsPresent, rc = localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    !> For legacy reasons read detP into lDetP
    if (.not.labelIsPresent) then
      call MOSSCO_ConfigGet(config, label='pflux_detP', value=pflux_lDetP, &
        defaultValue=0.2d0, isPresent=labelIsPresent, rc = localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

      if (labelIsPresent) then
        write(message,'(A)') trim(gridCompName)// ' found deprecated config item pflux_detP, please use pflux_lDetP.'
        call ESMF_LogWrite(trim(message), ESMF_LOGMSG_WARNING)
      endif
    endif

    if (labelIsPresent) then
      write(message,'(A,ES9.2)') trim(gridCompName)// ' found config item pflux_lDetP = ',pflux_lDetP
    else
      write(message,'(A,ES9.2)') trim(gridCompName)// ' uses default pflux_lDetP = ',pflux_lDetP
    endif
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)
    call ESMF_AttributeSet(gridComp, 'boundary_phosphate_flux', pflux_lDetP, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  end subroutine read_config

#undef ESMF_METHOD
#define ESMF_METHOD "set_boundary_flags"
!> set ESMF attributes "required_flag", "required" and "optional" for
!! all boundary conditions in the importState
  subroutine set_boundary_flags(sed,state)
    type(type_sed)             :: sed
    type(ESMF_State)           :: state
    character(len=ESMF_MAXSTR) :: name,varname,attbasename
    integer                    :: n
    integer(ESMF_KIND_I4)      :: localrc

    name='temperature_at_soil_surface'
    call set_item_flags(state,name,requiredFlag=.true.,requiredRank=2)

    do n=1,size(sed%model%state_variables)
      if (sed%model%state_variables(n)%standard_variable%name/='') then
        varname = &
          trim(sed%model%state_variables(n)%standard_variable%name)
      else
      !> otherwise use CF-ed version of long_name
        varname = trim(only_var_name( &
           sed%model%state_variables(n)%long_name))
      endif
      attbasename=trim(varname)//'_at_soil_surface'
      call set_item_flags(state,attbasename,requiredFlag=.true.,requiredRank=2)

      if (sed%model%state_variables(n)%properties%get_logical( &
            'particulate',default=.false.)) then
        name = trim(varname)//'_z_velocity_at_soil_surface'
        call set_item_flags(state,name,requiredFlag=.true.,requiredRank=2)
      endif
    enddo
  end subroutine set_boundary_flags

#undef ESMF_METHOD
#define ESMF_METHOD "check_NaN"
  subroutine check_NaN(sed,rc)
    type(type_sed)             :: sed
    integer, intent(out)       :: rc
    character(len=ESMF_MAXSTR) :: message, varname
    integer                    :: i, j, k, n
    logical                    :: found_NaN, list_indices, list_varnames

    found_NaN = .false.
    list_indices = .false.
    list_varnames = .false.

    !spacial loop (How about halo zones?)
    do i=1,sed%inum
      do j=1,sed%jnum
        do k=1,sed%knum
          if ( sed%mask(i,j,k) ) cycle
          if ( any(sed%conc(i,j,k,:) /= sed%conc(i,j,k,:)) ) then
#ifdef DEBUG_NAN
            write(message,'(A,3i4)')  '  NaN detected at indices (i,j,k) ',i,j,k
            call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
#endif
            do n=1,sed%nvar
              if ( sed%conc(i,j,k,n) /= sed%conc(i,j,k,n) ) then
                found_NaN = .true.
#ifdef DEBUG_NAN
                varname = trim(sed%export_states(n)%standard_name)
                write(message,'(A)')  '  NaN detected for '//trim(varname)
                call ESMF_LogWrite(trim(message),ESMF_LOGMSG_ERROR, ESMF_CONTEXT)
                if (.not. list_varnames)  exit ! n-loop
#else
                rc = ESMF_RC_VAL_OUTOFRANGE
                return
#endif
              endif
            enddo
            exit ! k-loop
          endif
        enddo
      enddo
    enddo
    if (found_NaN) then
      rc = ESMF_RC_VAL_OUTOFRANGE
    endif

  end subroutine check_NaN

subroutine getSurfaceItem(state, fieldName, farray3, kwe, owner, rc)

  type(ESMF_State), intent(inout)    :: state
  character(len=*), intent(in)       :: fieldName
  real(ESMF_KIND_R8), intent(inout)  :: farray3(:,:,:)
  type(ESMF_KeywordEnforcer), intent(in), optional :: kwe
  integer(ESMF_KIND_I4), intent(out), optional     :: rc
  character(len=*), intent(in), optional           :: owner

  integer(ESMF_KIND_I4)         :: localrc, rc_
  integer(ESMF_KIND_I4)         :: rank, ubnd(2), lbnd(2)
  real(ESMF_KIND_R8), pointer   :: farrayPtr1(:) => null()
  real(ESMF_KIND_R8), pointer   :: farrayPtr2(:,:) => null()
  type(ESMF_StateItem_Flag)     :: itemType
  type(ESMF_Field)              :: field
  type(ESMF_FieldStatus_Flag)   :: fieldStatus
  real(ESMF_KIND_R8)            :: defaultValue
  character(ESMF_MAXSTR)        :: message, owner_
  logical                       :: isPresent

  rc_ = ESMF_SUCCESS
  owner_ = '--'
  if (present(kwe)) rc_ = ESMF_SUCCESS
  if (present(rc)) rc = ESMF_SUCCESS

  call ESMF_StateGet(state, fieldName, itemType=itemType, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if (itemType /= ESMF_STATEITEM_FIELD) then
    return
  endif

  call ESMF_StateGet(state, fieldName, field=field, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  call ESMF_FieldGet(field, status=fieldStatus, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if (fieldStatus /= ESMF_FIELDSTATUS_COMPLETE) then

    call ESMF_AttributeGet(field, 'default_value', defaultValue, &
      defaultValue=-1D30, isPresent=isPresent, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)

    if (isPresent) then
      farray3(RANGE2D,1)=defaultValue
      write(message,'(A)') trim(owner_)//' applied default value from '
      call MOSSCO_FieldString(field, message, rc=localrc)
    else
      write(message,'(A)') trim(owner_)//' removed and destroyed '
      call MOSSCO_FieldString(field, message, rc=localrc)
      _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc)
      call ESMF_StateRemove(state,(/trim(fieldName)/), rc=localrc)
      call ESMF_FieldDestroy(field, rc=localrc)
    endif
    call ESMF_LogWrite(trim(message),ESMF_LOGMSG_INFO)

    return
  endif

  call ESMF_FieldGet(field, rank=rank, rc=localrc)
  _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

  if (rank == 2) then
    call ESMF_FieldGet(field, farrayPtr=farrayPtr2, &
      exclusiveUBound=ubnd, exclusiveLBound=lbnd, rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    farray3(RANGE2D,1) = farrayPtr2(RANGE2D)

  elseif (rank == 1) then

    call ESMF_FieldGet(field, farrayPtr=farrayPtr1, &
      exclusiveUBound=ubnd(1:1), exclusiveLBound=lbnd(1:1), rc=localrc)
    _MOSSCO_LOG_AND_FINALIZE_ON_ERROR_(rc_)

    farray3(RANGE1D,lbnd(1),1)=farrayPtr1(RANGE1D)
  endif

end subroutine getSurfaceItem

end module fabm_sediment_component
